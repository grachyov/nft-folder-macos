{
  "abId" : "26",
  "address" : "0xa7d8d9ef8d8ce8992df33d8b8cf4aebabd5bd270",
  "kind" : "p5js100",
  "name" : "EnergySculpture",
  "screensaverFileName" : "EnergySculpture",
  "value" : "let hashPairs = [];\n\nfor (let j = 0; j < 32; j++) {\n     hashPairs.push(tokenData.hash.slice(2 + (j * 2), 4 + (j * 2)));\n}\n\nlet decPairs = hashPairs.map(x => {\n     return parseInt(x, 16);\n});\n\nlet mainShader;\nlet timer = 0;\n\nlet morph;\nlet delayAmount;\nlet speed;\nlet hueC;\nlet dimLayerOne;\nlet dimLayerTwo;\nlet bounceSpeed; \/\/range1-6\nlet morphSpeeds;\nlet plotTime; \/\/1-6\nlet phase = 0;\n\nfunction preload() {\n\n     randomFromHash();\n     mainShader = getShader(this._renderer);\n}\n\n\nfunction setup() {\n\n     createCanvas(windowWidth, windowHeight, WEBGL);\n     shader(mainShader);\n\n     mainShader.setUniform(\"speed\", speed);\n     mainShader.setUniform(\"delayAmount\", delayAmount);\n     mainShader.setUniform(\"hueC\", hueC);\n     mainShader.setUniform(\"dimLayerOne\", dimLayerOne);\n     mainShader.setUniform(\"dimLayerTwo\", dimLayerTwo);\n     mainShader.setUniform(\"bounceSpeed\", bounceSpeed);\n     mainShader.setUniform(\"morphSpeeds\", morphSpeeds);\n     mainShader.setUniform(\"plotTime\", plotTime);\n\n}\n\nfunction draw() {\n\n     mainShader.setUniform(\"time\", phase + millis() \/ 1000.0);\n     rect(0, 0, width, height);\n\n}\n\nfunction randomFromHash() {\n\n     phase = map(decPairs[0], 0, 255, 0, 100);\n     \/\/phase =  map(random(0,255), 0, 255, 0, 100);\n     let ranDelay = round(map(decPairs[0], 0, 255, 1, 3));\n     \/\/let ranDelay = round(map(random(0,255), 0, 255, 1, 3));\n     if (ranDelay == 1) {\n          delayAmount = 0.02;\n     }\n     if (ranDelay == 2) {\n          delayAmount = 0.08;\n     }\n     if (ranDelay == 3) {\n          delayAmount = 0.12;\n     }\n\n     let ranSpeed = round(map(decPairs[1], 0, 255, 1, 3));\n     \/\/let ranSpeed = round(map(random(0,255), 0, 255, 1, 3));\n     if (ranSpeed == 1) {\n          speed = 0.1;\n     }\n     if (ranSpeed == 2) {\n          speed = 0.3;\n     }\n     if (ranSpeed == 3) {\n          speed = 0.6;\n     }\n\n     \/\/print(speed);\n     let ranColor = map(decPairs[2], 0, 255, 0, 1);\n     \/\/let ranColor = map(random(0,255), 0, 255, 0, 1);\n\n     hueC = ranColor;\n\n     let ranDim = round(map(decPairs[3], 0, 255, 0, 1));\n     \/\/let ranDim = round(map(random(0,255), 0, 255, 0, 1));\n\n     if (ranDim == 0) {\n          \/\/ let dimOne = round(map(random(0,255), 0, 255, 0, 9));\n          let dimOne = round(map(decPairs[0], 0, 255, 0, 9));\n          \/\/let dimTwo = round(map(random(0,255), 0, 255, 0, 9));\n          let dimTwo = round(map(decPairs[1], 0, 255, 0, 9));\n          dimLayerOne = [dimOne, dimOne, dimOne];\n          dimLayerTwo = [dimTwo, dimTwo, dimTwo];\n     }\n     if (ranDim == 1) {\n\n          dimLayerOne = [round(map(decPairs[0], 0, 255, 0, 9)), round(map(decPairs[1], 0, 255, 0, 9)), round(map(decPairs[2], 0, 255, 0, 9))];\n          dimLayerTwo = [round(map(decPairs[3], 0, 255, 0, 9)), round(map(decPairs[4], 0, 255, 0, 9)), round(map(decPairs[5], 0, 255, 0, 9))];\n\n     }\n\n     let ranBounce = round(map(decPairs[4], 0, 255, 1, 6));\n     \/\/let ranBounce = round(map(random(0,255), 0, 255, 1, 6));\n\n     bounceSpeed = ranBounce; \/\/range1-6\n     morphSpeeds = [round(map(decPairs[0], 0, 255, 1, 6)), round(map(decPairs[1], 0, 255, 1, 6)), round(map(decPairs[2], 0, 255, 1, 6))];\n     let ranPlot = round(map(decPairs[5], 0, 255, 1, 6))\n     plotTime = ranPlot; \/\/1-6\n\n}\n\nfunction getShader(_renderer) {\n     const vert = `\n        attribute vec3 aPosition;\n        attribute vec2 aTexCoord;\n\n        varying vec2 vTexCoord;\n\n        void main() {\n            vTexCoord = aTexCoord;\n\n            vec4 positionVec4 = vec4(aPosition, 1.0);\n            positionVec4.xy = positionVec4.xy * 2.0 - 1.0;\n\n            gl_Position = positionVec4;\n        }\n    `;\n\n     const frag = `\n        precision highp float;\n\n        varying vec2 vTexCoord;\n\n        const float WIDTH = ${windowWidth}.0;\n        const float HEIGHT = ${windowHeight}.0;\n        \n        #define PI 3.14159265359\n        #define TWO_PI 6.28318530718\n        uniform float time;\n        \n        #define size 0.55\n        #define lineSize 0.175\n        #define blur 0.2\n        #define grid 2.3\n        #define grid2 3.3\n        #define morph 3.3\n        \n        uniform float delayAmount; \n        uniform float speed;\n        uniform float hueC;\n        uniform vec3 dimLayerOne;\n        uniform vec3 dimLayerTwo;\n        uniform float bounceSpeed;\n        uniform vec3 morphSpeeds;\n        uniform float plotTime;\n\n        float impulse( float k, float x )\n        {\n    float h = k*x;\n    return h*exp(1.0-h);\n        }\n\n        float plot(float dis){\n    float pct = smoothstep(dis,dis+blur,0.5)-smoothstep(lineSize+dis,lineSize+dis+blur,0.5);     \n    return   pct ;\n        }\n\n        vec3 wooper(vec2 st, float timeCheck){\n    \n    vec3 color = vec3(0.0);\n    vec2 pos = vec2(0.5)-abs(st);\n\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n    \n    float gridSine = 5.+ (grid2*sin(timeCheck\/bounceSpeed * PI));\n\n    r = fract(impulse(r,gridSine)*grid);\n    \n    float morphSine = 0.2 + ( 1.+sin(timeCheck\/morphSpeeds.x * PI) \/2.)*morph;\n    float morphSine2 = 0.2 + ( 1.+sin(timeCheck\/morphSpeeds.y * PI) \/2.)*morph;\n    float morphSine3 = 0.2 + ( 1.+sin(timeCheck\/morphSpeeds.z * PI) \/2.)*morph;\n    \n    float f = ( size*cos(a*dimLayerOne.x + timeCheck\/plotTime) + size*cos(a*dimLayerTwo.x + timeCheck*plotTime))\/2.;\n    float p = plot(1.-smoothstep(f,f+0.9,r*morphSine));\n    \n    float f2 = ( size*cos(a*dimLayerOne.y + timeCheck\/plotTime) + size*cos(a*dimLayerTwo.y + timeCheck*plotTime))\/2.;\n    float p2 = plot(1.-smoothstep(f2,f2+0.9,r*morphSine2));\n    \n    float f3 = ( size*cos(a*dimLayerOne.z + timeCheck\/plotTime) + size*cos(a*dimLayerTwo.z + timeCheck*plotTime))\/2.;\n    float p3 = plot(1.-smoothstep(f3,f3+0.9,r*morphSine3));\n    \n    color.r = p;\n    color.g = p2 *st.x;\n    color.b = p3;\n \n    return(color);\n        }\n\n        vec3 powerParticle(vec2 st){\n  \n    st.y += ((st.x*0.05)*sin(time\/10.*PI)+(st.x*0.1)*sin(time\/12.*PI))\/2.;\n    st.x += ((st.y*0.05)*sin(time\/10.*PI) + (st.y*0.1)*sin(time\/12.*PI))\/2.;\n    \n    vec2 pos = vec2(0.25+0.25*sin(time))-abs(st);\n\n    float r = length(pos);\n    float d = distance(st,vec2(0.5))* (sin(time\/8.));\n    d = distance(vec2(.5),st);\n    vec3 colorNew = vec3(0);\n   \n    float delay = delayAmount;\n    float timerChecker = time * speed ;\n    for(int i=0;i<10;i++) {\n     \n      vec3 colorCheck = wooper(st, timerChecker+ float(i)*delay)* (1.-(float(i)\/10.0));\n      colorNew+= colorCheck ;\n    }\n    \n    return(colorNew);\n        }\n\n        vec3 rgb2hsb( in vec3 c ){\n                vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n                vec4 p = mix(vec4(c.bg, K.wz),\n                                         vec4(c.gb, K.xy),\n                                         step(c.b, c.g));\n                vec4 q = mix(vec4(p.xyw, c.r),\n                                         vec4(c.r, p.yzx),\n                                         step(p.x, c.r));\n                float d = q.x - min(q.w, q.y);\n                float e = 1.0e-10;\n                return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)),\n                                        d \/ (q.x + e),\n                                        q.x);\n        }\n\n        \/\/  Function from IÃ±igo Quiles\n        \/\/  https:\/\/www.shadertoy.com\/view\/MsS3Wc\n        vec3 hsb2rgb( in vec3 c ){\n                vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                                                                 6.0)-3.0)-1.0,\n                                                 0.0,\n                                                 1.0 );\n                rgb = rgb*rgb*(3.0-2.0*rgb);\n                return c.z * mix(vec3(1.0), rgb, c.y);\n        }\n        \n        void main() {\n            \n                        float rel = WIDTH\/HEIGHT;\n            vec2 st = vTexCoord.xy ;\n                        st.x -= 0.5;\n            st.x *=rel;\n                        st.x += 0.5;\n            vec3 powerColor = powerParticle(st);\n\n            vec3 hue = rgb2hsb(powerColor);\n            hue.x = hueC;\n            hue.y = 0.3;\n            float d = 1.-distance(vec2(.5),st);\/\/*2.;\n\n            float d1 = smoothstep(-0.2,1.,d);\n\n            d = smoothstep(0.5,1.0,d);\n\n            vec3 back = vec3(d1,0.,0.);\n            vec3 backHue = rgb2hsb(back);\n            backHue.x = hueC;\n                        \n                        gl_FragColor  = vec4(hsb2rgb(backHue)*0.5 +(hsb2rgb(hue)*d) +(powerColor*d*0.4),1.0);\n        }\n    `;\n\n     return new p5.Shader(_renderer, vert, frag);\n}"
}