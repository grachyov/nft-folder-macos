{
  "kind" : "p5js100",
  "screensaverFileName" : "slash.slash.slash",
  "value" : "class Random {\n    constructor() {\n        this.useA = false;\n        let sfc32 = function(uint128Hex) {\n            let a = parseInt(uint128Hex.substr(0, 8), 16);\n            let b = parseInt(uint128Hex.substr(8, 8), 16);\n            let c = parseInt(uint128Hex.substr(16, 8), 16);\n            let d = parseInt(uint128Hex.substr(24, 8), 16);\n            return function() {\n                a |= 0;\n                b |= 0;\n                c |= 0;\n                d |= 0;\n                let t = (((a + b) | 0) + d) | 0;\n                d = (d + 1) | 0;\n                a = b ^ (b >>> 9);\n                b = (c + (c << 3)) | 0;\n                c = (c << 21) | (c >>> 11);\n                c = (c + t) | 0;\n                return (t >>> 0) \/ 4294967296;\n            };\n        };\n        this.prngA = new sfc32(tokenData.hash.substr(2, 32));\n        this.prngB = new sfc32(tokenData.hash.substr(34, 32));\n        for (let i = 0; i < 1e6; i += 2) {\n            this.prngA();\n            this.prngB();\n        }\n    }\n    random_dec() {\n        this.useA = !this.useA;\n        return this.useA ? this.prngA() : this.prngB();\n    }\n    random_num(a, b) {\n        return a + (b - a) * this.random_dec();\n    }\n\n    random_int(a, b) {\n        return Math.floor(this.random_num(a, b + 1));\n    }\n\n    random_choice(list) {\n        return list[this.random_int(0, list.length - 1)];\n    }\n}\n\nlet R, rnd, rint, choice, sn, rexp, rtri, wPick;\nlet W, H, vec;\nlet canvas,\n    PPI = 96;\nlet MM = PPI \/ 25.4;\nconst MAX_THREAD_NUMBER = 15;\n\n\nfunction setupRandom() {\n    R = new Random();\n}\n\n\nfunction saveMyPNG() {\n    save(canvas, `${tokenData.tokenId}.png`);\n}\n\n\nfunction saveMySVG(width_mm, height_mm) {\n    let polyColors = new Set(polys.map((p) => p.sc.toString()));\n    if (polyColors.size > MAX_THREAD_NUMBER) throw \"too many colors\";\n\n    let svgcanvas = createSVGCanvas(width_mm, height_mm, true);\n\n    saveSVGElement(svgcanvas, `${tokenData.tokenId}.svg`);\n}\n\n\nfunction saveSVGElement(svgElement, name) {\n    svgElement.setAttribute(\"xmlns\", \"http:\/\/www.w3.org\/2000\/svg\");\n    var svgData = svgElement.outerHTML;\n    var preface = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n';\n    var svgBlob = new Blob([preface, svgData], {\n        type: \"image\/svg+xml;charset=utf-8\",\n    });\n    var svgUrl = URL.createObjectURL(svgBlob);\n    var downloadLink = document.createElement(\"a\");\n    downloadLink.href = svgUrl;\n    downloadLink.download = name;\n    document.body.appendChild(downloadLink);\n    downloadLink.click();\n    document.body.removeChild(downloadLink);\n    return svgElement\n}\n\n\nfunction createSVGCanvas(width_mm, height_mm, localSave) {\n    console.log(width_mm, height_mm);\n    ns = \"http:\/\/www.w3.org\/2000\/svg\";\n    svg = document.createElementNS(ns, \"svg\");\n    groups = [];\n\n\n    svg.setAttribute(\"version\", \"1.1\");\n    svg.setAttribute(\"xmlns:xlink\", \"http:\/\/www.w3.org\/2000\/xlink\");\n    svg.setAttribute(\"width\", \"100vw\");\n    svg.setAttribute(\"height\", \"100vh\");\n    svg.setAttribute(\"viewBox\", \"0 0 \" + width_mm + \" \" + height_mm);\n\n\n    let layers = {};\n    let layer;\n\n    let colorsUsed = new Set();\n    polys.forEach((x) => colorsUsed.add(x.sc));\n\n    let borderColorsUsed = new Set();\n    bPolys.forEach((x) => borderColorsUsed.add(x.sc));\n\n\n    \/\/create underlayment layer\n    layerName = colors[14].color;\n    layer = document.createElementNS(ns, \"g\");\n    layer.setAttribute(\"id\", layerName.replaceAll(\",\", \"\"));\n    layer.setAttribute(\"style\", `fill:none;stroke-width:1;stroke:rgb(${colors[14].rgb});`);\n    svg.appendChild(layer);\n    layers[layerName.replaceAll(\",\", \"\")] = layer;\n\n\n    let newPath = document.createElementNS(ns, \"path\");\n    let d = `M ${1} ${1} L ${width_mm-1} ${1} L ${width_mm-1} ${height_mm-1} L ${1} ${height_mm-1} L ${1} ${1}`;\n    newPath.setAttribute(\"d\", d);\n    layer.appendChild(newPath);\n\n\n\n    \/\/create infill layers\n    for (let i = 0; i < colors.length - 1; i++) {\n        layerName = colors[i].color;\n        layer = document.createElementNS(ns, \"g\");\n        layer.setAttribute(\"id\", layerName.replaceAll(\",\", \"\"));\n        layer.setAttribute(\"style\", `fill:none;stroke-width:1;stroke:rgb(${colors[i].rgb});`);\n\n        svg.appendChild(layer);\n        layers[layerName.replaceAll(\",\", \"\")] = layer;\n\n        \/\/ if no stitches in that layer, add a ghost stitch to make sure it's recognized by machine for ordering purposes \n        if (!colorsUsed.has(colors[i].rgb)) {\n            let newPath = document.createElementNS(ns, \"path\");\n            let d = `M ${vertices[0][0][0]} ${vertices[0][0][1]} L ${vertices[0][0][0]+1} ${vertices[0][0][1]+1}`;\n            newPath.setAttribute(\"d\", d);\n            layer.appendChild(newPath);\n        }\n    }\n\n    \/\/\/put navy border first\n    layerName = colors[14].color + \"b\";\n    layer = document.createElementNS(ns, \"g\");\n    layer.setAttribute(\"id\", layerName.replaceAll(\",\", \"\"));\n    layer.setAttribute(\"style\", `fill:none;stroke-width:1;stroke:rgb(${colors[14].rgb});`);\n\n    svg.appendChild(layer);\n    layers[layerName.replaceAll(\",\", \"\")] = layer;\n    \/\/ if no stitches in that layer, add a ghost stitch to make sure it's recognized by machine for ordering purposes \n    if (!borderColorsUsed.has(colors[14].rgb)) {\n        let newPath = document.createElementNS(ns, \"path\");\n        let d = `M ${vertices[0][0][0]} ${vertices[0][0][1]} L ${vertices[0][0][0]+1} ${vertices[0][0][1]+1}`;\n        newPath.setAttribute(\"d\", d);\n        layer.appendChild(newPath);\n    }\n\n    \/\/create border layers (after navy)\n    for (let i = 0; i < colors.length - 1; i++) {\n        layerName = colors[i].color + \"b\";\n        layer = document.createElementNS(ns, \"g\");\n        layer.setAttribute(\"id\", layerName.replaceAll(\",\", \"\"));\n        layer.setAttribute(\"style\", `fill:none;stroke-width:1;stroke:rgb(${colors[i].rgb});`);\n\n        svg.appendChild(layer);\n        layers[layerName.replaceAll(\",\", \"\")] = layer;\n        \/\/ if no stitches in that layer, add a ghost stitch to make sure it's recognized by machine for ordering purposes \n        if (!borderColorsUsed.has(colors[i].rgb)) {\n            let newPath = document.createElementNS(ns, \"path\");\n            let d = `M ${vertices[0][0][0]} ${vertices[0][0][1]} L ${vertices[0][0][0]+1} ${vertices[0][0][1]+1}`;\n            newPath.setAttribute(\"d\", d);\n            layer.appendChild(newPath);\n        }\n    }\n\n\n\n    \/\/populate layers\n    polys.map((p) => {\n        let c = p.sc.toString();\n        let cl = colors.find(item => item.rgb === p.sc);\n\n        let path = p.shape;\n        let newPath = document.createElementNS(ns, \"path\");\n        let d = `M ${path[0].x} ${path[0].y} `;\n        for (let i = 1; i < path.length; i++) {\n            d += `L ${path[i].x} ${path[i].y} `;\n        }\n        newPath.setAttribute(\"d\", d);\n        layers[cl.color].appendChild(newPath);\n    });\n\n    bPolys.map((p) => {\n        let c = p.sc.toString();\n        let cl = colors.find(item => item.rgb === p.sc);\n\n        let path = p.shape;\n        let newPath = document.createElementNS(ns, \"path\");\n        let d = `M ${path[0].x} ${path[0].y} `;\n        for (let i = 1; i < path.length; i++) {\n            d += `L ${path[i].x} ${path[i].y} `;\n        }\n        newPath.setAttribute(\"d\", d);\n\n        layers[cl.color + \"b\"].appendChild(newPath);\n    });\n\n    if (localSave) {\n        return svg;\n    } else {\n        return svg.outerHTML;\n    }\n}\n\n\n\nfunction getKeyByValue(object, value) {\n    return Object.keys(object).find(key =>\n        object[key] === value);\n}\n\nclass Poly {\n    constructor(\n        shape,\n        x = 0,\n        y = 0,\n        s = 1,\n        r = 0,\n        closed = true,\n        sc = undefined,\n        c = undefined\n    ) {\n        this.shape = shape.map((v) => {\n            let cv = v.copy();\n            let rv = cv.rotate(r);\n            return createVector(x + rv.x * s, y + rv.y * s);\n        });\n        if (closed) {\n            this.shape.push(this.shape[0].copy());\n        }\n        this.sc = sc\n        if (sc == undefined) this.sc = color(0);\n        this.c = c;\n    }\n\n    reverse() {\n        let shape = [];\n        for (let i = this.shape.length - 1; i >= 0; i--) {\n            shape.push(this.shape[i]);\n        }\n        this.shape = shape;\n        return this;\n    }\n\n    copy(x = undefined, y = undefined, s = 1, c = undefined, sc = undefined) {\n        if (x == undefined) x = 0\n        if (y == undefined) y = 0\n        if (s == undefined) s = 1\n        if (c == undefined) c = this.c\n        if (sc == undefined) sc = this.sc\n        return new Poly(this.shape, x, y, s, 0, this.closed, sc, c);\n    }\n\n\n    setColorValue(v) {\n        this.colorValue = v;\n        return this;\n    }\n\n\n    setOrderValue(v) {\n        this.orderValue = v;\n        return this;\n    }\n\n\n    setColor(sc = undefined, c = undefined) {\n        this.sc = sc;\n        this.c = c;\n        return this;\n    }\n\n\n}let vertices = [];\nlet polys = [];\nlet bPolys = [];\nlet frCount = 0;\nlet noiseAlpha = 0;\nlet embroiderySizeW = 3 * PPI;\nlet embroiderySizeH = PPI;\nlet colorStyleOptions = [{\n        name: \"alternating\",\n        weight: 3\n    },\n    {\n        name: \"allSolidGrad\",\n        weight: 3\n    },\n    {\n        name: \"allSolidRandom\",\n        weight: 3\n    },\n    {\n        name: \"allSolid\",\n        weight: 2\n    },\n    {\n        name: \"allSolidGreyWhite\",\n        weight: 2\n    },\n    {\n        name: \"longGrad\",\n        weight: 4\n    },\n    {\n        name: \"shortGrad\",\n        weight: 4\n    },\n    {\n        name: \"hyper\",\n        weight: 1\n    },\n    {\n        name: \"patchwork\",\n        weight: 3\n    },\n    {\n        name: \"splitTwo\",\n        weight: 2\n    },\n    {\n        name: \"splitAll\",\n        weight: 4\n    },\n    {\n        name: \"biColorGrad\",\n        weight: 5\n    }\n];\nlet colorStyle = [];\nfor (let i in colorStyleOptions) {\n    for (let s = 0; s < colorStyleOptions[i].weight; s++) {\n        colorStyle.push(colorStyleOptions[i].name)\n    }\n}\n\nlet borderStyle = [\"allWhite\", \"allGrey\", \"allNavy\", \"gradient\", \"random\", \"singleColor\"];\nlet numSlashes;\nlet slashInsideColors = [];\nlet slashBorderColors = [];\nlet slashOrientations = [];\nlet slashpWs = [];\nlet startColor;\nlet borderStartColor;\nlet totalFillStitchCount = 0;\nlet globalSpread;\nlet globalSpeed;\nlet randomColorA;\nlet randomColorB;\nlet hyperType;\nlet hyperAll;\nlet translateValue;\nlet totalWidth = 0;\nlet pGramHeightInMM = 19;\nlet pH = pGramHeightInMM * MM;\nlet angle;\nlet arrow;\nlet totalCount = 0;\nlet lnOrientation;\nlet scaler;\nlet switchScaler;\nlet partyMode;\nlet noiseMode;\nlet outlineMode=false;\nlet finishLine=false;\nlet lonely = false;\nlet forPrint = false;\nlet activeFillLine = [];\nlet slashFrames = [];\n\n\/\/parallelogram spacing\nlet pS = 18;\n\nlet fillStitchLengthInMM = 1;\nlet underlaymentStitchLengthInMM = 2;\nlet underlaymentSpacingInMM = 1.5;\nlet LineSpacingInMM = 0.35;\nlet backgroundColor = 255;\n\n\/\/\/\/\/ THREAD COLOR ORDER \/\/\/\/\/\n\/\/\/\/\/ 1 navy (underlayment)\n\/\/\/\/\/ 2 red\n\/\/\/\/\/ 3 pink\n\/\/\/\/\/ 4 magenta\n\/\/\/\/\/ 5 purple\n\/\/\/\/\/ 6 dark blue\n\/\/\/\/\/ 7 blue\n\/\/\/\/\/ 8 green\n\/\/\/\/\/ 9 light green\n\/\/\/\/\/ 10 chartreuse\n\/\/\/\/\/ 11 yellow\n\/\/\/\/\/ 12 light orange\n\/\/\/\/\/ 13 orange\n\/\/\/\/\/ 14 white\n\/\/\/\/\/ 15 grey\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\nlet colors = [{\n        color: \"red\",\n        val: 0,\n        rgb: [255, 23, 0],\n        orderValue: 0\n    },\n    {\n        color: \"magenta\",\n        val: 1,\n        rgb: [255, 0, 211],\n        orderValue: 0\n    },\n    {\n        color: \"purple\",\n        val: 2,\n        rgb: [154, 0, 255],\n        orderValue: 0\n    },\n    {\n        color: \"blue\",\n        val: 3,\n        rgb: [18, 0, 255],\n        orderValue: 0\n    },\n    {\n        color: \"lightblue\",\n        val: 4,\n        rgb: [0, 191, 255],\n        orderValue: 0\n    },\n    {\n        color: \"aqua\",\n        val: 5,\n        rgb: [0, 255, 205],\n        orderValue: 0\n    },\n    {\n        color: \"green\",\n        val: 6,\n        rgb: [0, 255, 88],\n        orderValue: 0\n    },\n    {\n        color: \"chartreuse\",\n        val: 7,\n        rgb: [205, 255, 0],\n        orderValue: 0\n    },\n    {\n        color: \"yellow\",\n        val: 8,\n        rgb: [255, 248, 0],\n        orderValue: 0\n    },\n    {\n        color: \"marigold\",\n        val: 9,\n        rgb: [255, 210, 0],\n        orderValue: 0\n    },\n    {\n        color: \"orange\",\n        val: 10,\n        rgb: [255, 165, 0],\n        orderValue: 0\n    },\n    {\n        color: \"darkorange\",\n        val: 11,\n        rgb: [255, 119, 0],\n        orderValue: 0\n    },\n    {\n        color: \"white\",\n        val: 12,\n        rgb: [255, 255, 255],\n        orderValue: 0\n    },\n    {\n        color: \"grey\",\n        val: 13,\n        rgb: [125, 125, 125],\n        orderValue: 0\n    },\n    {\n        color: \"navy\",\n        val: 14,\n        rgb: [42, 40, 116],\n        orderValue: 0\n    },\n\n]\n\n\n\nfunction presetup() {\n    canvas = createCanvas(window.windowWidth, window.windowHeight)\n\n    setupRandom()\n    noFill()\n\n}\n\nfunction setup() {\n    presetup();\n    background(255);\n    arrow = R.random_choice([true, false]);\n\n    angle = arrow ? radians(R.random_choice([25, 25, 25, 25, 50, 50, 50, 50])) : radians(R.random_choice([0, 25, 25, 25, 25, 50, 50, 50, 50]));\n\n\n    colorStyle = R.random_choice(colorStyle);\n    borderStyle = R.random_choice(borderStyle);\n    if (colorStyle == \"hyper\") {\n        hyperType = R.random_int(0, 1);\n        hyperSingle = R.random_int(0, 1);\n        if (hyperSingle) hyperSingle = R.random_int(1, vertices.length);\n    }\n\n\n\n    lnOrientation = (colorStyle == \"biColorGrad\" || arrow) ? \"v\" : R.random_choice([\"h\", \"v\"]);\n\n    let smallerDim = Math.min(width, height) == width ? width : height;\n    scaler = smallerDim \/ (smallerDim == width ? embroiderySizeW : embroiderySizeH * 2);\n\n    let w = 0;\n\n    let s = 0;\n    while (w < embroiderySizeW) {\n        let slashWidth = R.random_choice([20, 25, 30, 35]);\n        let pGram = drawParallelogram(0, pH + (embroiderySizeH - pH) \/ 2, slashWidth, pH, angle);\n        let v1 = createVector(pGram[1][0], pGram[1][1]);\n        let v2 = createVector(pGram[2][0], pGram[2][1]);\n        let midPoint = p5.Vector.lerp(v1, v2, 0.5);\n        let totalSlashWidth = arrow ? midPoint.x - pGram[3][0] : pGram[1][0] - pGram[3][0];\n        if (s == 0) {\n            w = totalSlashWidth + pS;\n        } else if (w + slashWidth + pS < embroiderySizeW) {\n            w = w + slashWidth + pS;\n        } else {\n            break;\n        }\n        vertices.push(pGram);\n        s++;\n    }\n    numSlashes = vertices.length;\n    for (let s = 0; s < numSlashes; s++) {\n        activeFillLine.push(R.random_int(0, 99));\n        slashFrames.push(0);\n    }\n    translateValue = ((embroiderySizeW - w + pS) \/ 2);\n\n    \/\/global color generation here\n    globalSpread = R.random_int(3, 20);\n    globalSpeed = R.random_int(0, 3);\n    startColor = R.random_int(0, 11);\n    borderStartColor = R.random_int(0, 11);\n    randomColorA = colorStyle == \"biColorGrad\" ? R.random_int(0, 13) : colorStyle == \"allSolidGreyWhite\" ? R.random_int(12, 13) : R.random_int(0, 11);\n    randomColorB = colorStyle == \"biColorGrad\" ? R.random_int(0, 13) : colorStyle == \"allSolidGreyWhite\" ? R.random_int(12, 13) : R.random_int(0, 11);\n\n    while (randomColorB == randomColorA) {\n        randomColorB = colorStyle == \"allSolidGreyWhite\" ? R.random_int(12, 13) : R.random_int(0, 11);\n    }\n\n\n\n    for (let slash = 0; slash < vertices.length; slash++) {\n        let thisOrientation = R.random_choice([\"h\", \"v\"]);\n        slashOrientations.push(thisOrientation);\n\n        let pW = vertices[slash][1][0] - vertices[slash][0][0];\n        slashpWs.push(pW);\n\n\n\n        \/\/outline\n        let borderColor;\n        if (borderStyle == \"allWhite\") {\n            borderColor = 12;\n        } else if (borderStyle == \"allGrey\") {\n            borderColor = 13;\n        } else if (borderStyle == \"allNavy\") {\n            borderColor = 14;\n        } else if (borderStyle == \"random\") {\n            borderColor = R.random_int(0, 11);\n        } else if (borderStyle == \"gradient\") {\n            borderColor = (borderStartColor + slash) % colors.slice(0, 12).length;\n        } else if (borderStyle == \"singleColor\") {\n            borderColor = borderStartColor;\n        } else {\n            borderColor = 0;\n        }\n        slashBorderColors.push(borderColor);\n\n        if (arrow) {\n            drawStitchedBorderLine([vertices[slash][3][0], vertices[slash][0][1]], [vertices[slash][2][0], vertices[slash][0][1]], LineSpacingInMM, \"h\", 7, borderColor); \/\/\/ arrow test\n        } else {\n            drawStitchedBorderLine(vertices[slash][0], vertices[slash][1], LineSpacingInMM, \"h\", 7, borderColor);\n        }\n        drawStitchedBorderLine(vertices[slash][1], vertices[slash][2], LineSpacingInMM, \"v\", 7, borderColor, arrow);\n        drawStitchedBorderLine(vertices[slash][2], vertices[slash][3], LineSpacingInMM, \"h\", 7, borderColor);\n        drawStitchedBorderLine(vertices[slash][3], vertices[slash][0], LineSpacingInMM, \"v\", 7, borderColor, arrow);\n\n\n        \/\/inside\n        drawStitchedFillLines(vertices[slash][0], vertices[slash][1], vertices[slash][2], vertices[slash][3], LineSpacingInMM, (lnOrientation == \"mix\" ? thisOrientation : lnOrientation), slash, (arrow && angle != radians(0)));\n\n\n        \/\/underlayment\n        drawUnderlayment(vertices[slash][0], vertices[slash][1], vertices[slash][2], vertices[slash][3], (lnOrientation == \"mix\" ? thisOrientation : lnOrientation), 14, arrow);\n\n\n\n\n        totalWidth = totalWidth + pW + pS;\n        partyMode = false;\n        noiseMode = true;\n    }\n\n\n\n    for (let i in polys) {\n        if (polys[i].colorValue == 14) {\n            polys[i].setColor(colors[14].rgb);\n        }\n    }\n\n    for (let a = 0; a < 14; a++) {\n\n        for (let i in polys) {\n            if (polys[i].colorValue == a) {\n                polys[i].setColor(colors[a].rgb);\n            }\n        }\n    }\n\n    for (let a = 0; a < 15; a++) {\n\n        for (let i in bPolys) {\n            if (bPolys[i].colorValue == a) {\n                bPolys[i].setColor(colors[a].rgb);\n            }\n        }\n    }\n\n}function draw() {\n    background(backgroundColor);\n   \n    translate(width \/ 2 - embroiderySizeW \/ 2 * scaler, (lonely||forPrint)?(height \/ 1.3 - embroiderySizeH \/ 2 * scaler):height \/ 2 - embroiderySizeH \/ 2 * scaler);\n    scale(scaler);\n    totalWidth = 0;\n    totalCount = 0;\n    \n    for (let slash = 0; slash < vertices.length; slash++) {\n        if (!outlineMode){\n        drawFillLines(vertices[slash][0], vertices[slash][1], vertices[slash][2], vertices[slash][3], LineSpacingInMM, (lnOrientation == \"mix\" ? thisOrientation : lnOrientation), slash, (arrow && angle != radians(0)));\n        }\n        for (let z = 10; z > 0; z--) {\n            strokeWeight(z \/ 4);\n            let col = outlineMode?(backgroundColor==255?0:255):shadeColor(colors[slashBorderColors[slash]].rgb, -z)\n            stroke(col);\n            drawArrowBorder(slash);\n\n        }\n        \n        totalWidth = totalWidth + slashpWs[slash] + pS;\n    }\n    frCount++;\n    \n}\n\n\n\nfunction drawStitchedBorderLine(a, b, spacing, lineOrientation, stitchLength, color, arrow) {\n    let counter = 0;\n    let stitchSpacingInMM = spacing;\n    let stitchSpacing = stitchSpacingInMM * MM;\n    let lineDistX = Math.abs(a[0] - b[0]);\n    let lineDistY = Math.abs(a[1] - b[1]);\n    let totalStitches = Math.floor((lineOrientation == \"h\" ? lineDistX : lineDistY) \/ stitchSpacing);\n    let spaceBetweenStitches = (lineOrientation == \"h\" ? lineDistX : lineDistY) \/ totalStitches;\n    let increment = spaceBetweenStitches \/ (lineOrientation == \"h\" ? lineDistX : lineDistY);\n    let connectedVectors = [];\n    if (arrow) {\n        for (let i = 0; i <= totalStitches; i++) {\n            counter++;\n            let v1 = createVector(a[0], a[1]);\n            let v1b = createVector(b[0], a[1]);\n            let v2 = createVector(b[0], b[1]);\n            let midPoint = p5.Vector.lerp(v1, v2, 0.5);\n            let pos;\n            let nextPos;\n            if (a[1] < b[1]) {\n                pos = i < totalStitches \/ 2 ? p5.Vector.lerp(v1b, midPoint, i * increment * 2) : p5.Vector.lerp(v1, v2, i * increment);\n                nextPos = i < totalStitches \/ 2 ? p5.Vector.lerp(v1b, midPoint, (i + 1) * increment * 2) : p5.Vector.lerp(v1, v2, (i + 1) * increment);\n            } else {\n                pos = i > totalStitches \/ 2 ? p5.Vector.lerp(v1b, midPoint, i * increment * 2) : p5.Vector.lerp(v1, v2, i * increment);\n                nextPos = i > totalStitches \/ 2 ? p5.Vector.lerp(v1b, midPoint, (i + 1) * increment * 2) : p5.Vector.lerp(v1, v2, (i + 1) * increment);\n            }\n            let v3 = createVector(pos.x - stitchLength \/ 2 + totalWidth + translateValue - 2, pos.y);\n            let v4 = createVector(pos.x + stitchLength \/ 2 + totalWidth + translateValue - 2, pos.y);\n            if (counter % 2 == 0) {\n                connectedVectors.push(v3);\n                connectedVectors.push(v4);\n\n            } else {\n                connectedVectors.push(v4);\n                connectedVectors.push(v3);\n\n            }\n\n        }\n        let p1 = new Poly(connectedVectors, 0, 0, 1, 0, 0);\n        p1.setColorValue(color);\n        bPolys.push(p1);\n    } else {\n        for (let i = 0; i <= totalStitches; i++) {\n            counter++;\n            let v1 = createVector(a[0], a[1]);\n            let v2 = createVector(b[0], b[1]);\n            let pos = p5.Vector.lerp(v1, v2, i * increment);\n            let nextPos = p5.Vector.lerp(v1, v2, (i + 1) * increment);\n            let v3 = lineOrientation == \"h\" ? createVector(pos.x + totalWidth + translateValue, pos.y - stitchLength \/ 2) : createVector(pos.x - stitchLength \/ 2 + totalWidth + translateValue, pos.y);\n            let v4 = lineOrientation == \"h\" ? createVector(pos.x + totalWidth + translateValue, pos.y + stitchLength \/ 2) : createVector(pos.x + stitchLength \/ 2 + totalWidth + translateValue, pos.y);\n            if (counter % 2 == 0) {\n                connectedVectors.push(v3);\n                connectedVectors.push(v4);\n            } else {\n                connectedVectors.push(v4);\n                connectedVectors.push(v3);\n            }\n        }\n        let p1 = new Poly(connectedVectors, 0, 0, 1, 0, 0);\n        p1.setColorValue(color);\n        bPolys.push(p1);\n    }\n\n}\nfunction drawStitchedFillLines(a, b, c, d, spacing, lineOrientation, slash, arrow) {\n    let inset = 2;\n    if (angle > 0 && lineOrientation == \"h\") spacing = spacing * (0.6 + angle);\n    let stitchSpacingInMM = spacing;\n    let stitchSpacing = stitchSpacingInMM * MM;\n    let stitchLength = fillStitchLengthInMM * MM;\n    let lineDistX = Math.abs(a[0] - b[0]);\n    let lineDistY = Math.abs(a[1] - d[1]);\n    let lineLength = (lineOrientation == \"h\" ? dist(a[0], a[1], d[0], d[1]) : lineDistX);\n    let totalLinesToBeStitched = Math.floor((lineOrientation == \"h\" ? lineDistX : lineDistY) \/ stitchSpacing);\n    let spaceBetweenLinesToBeStitched = (lineOrientation == \"h\" ? lineDistX : lineDistY) \/ totalLinesToBeStitched;\n    let incrementA = spaceBetweenLinesToBeStitched \/ (lineOrientation == \"h\" ? lineDistX : lineDistY);\n    let totalStitchesAcross = Math.floor(lineLength \/ stitchLength);\n    let spaceBetweenStitches = lineLength \/ totalStitchesAcross;\n    let incrementB = spaceBetweenStitches \/ lineLength;\n\n    let thisFillStitchCount = 0;\n    let localSpread = R.random_int(3, 20);\n    let localSpreadSwitch = R.random_choice([true, false]);\n    let slashSolidColor = R.random_int(0, 11);\n\n\n    for (let i = 1; i <= totalLinesToBeStitched - 1; i++) {\n        let col;\n\n        \/\/local color generation here\n        if (colorStyle == \"alternating\") {\n            col = slash % 2 == 0 ? randomColorA : randomColorB;\n        } else if (colorStyle == \"patchwork\") {\n            col = (startColor + Math.floor(totalFillStitchCount \/ (localSpreadSwitch ? localSpread : globalSpread))) % colors.slice(0, 12).length;\n        } else if (colorStyle == \"allSolidGrad\") {\n            col = (startColor + slash) % colors.slice(0, 12).length;\n        } else if (colorStyle == \"hyper\") {\n            if (!hyperSingle || (hyperSingle - 1) == slash) {\n                col = hyperType == 0 ? R.random_int(0, 11) : (startColor + totalFillStitchCount) % colors.slice(0, 12).length;\n            } else {\n                col = slashSolidColor;\n            }\n        } else if (colorStyle == \"allSolidRandom\") {\n            col = slashSolidColor;\n        } else if (colorStyle == \"longGrad\") {\n            col = (startColor + Math.floor(totalFillStitchCount \/ globalSpread) + R.random_int(0, 2)) % colors.slice(0, 12).length;\n        } else if (colorStyle == \"shortGrad\") {\n            col = (startColor + Math.floor(thisFillStitchCount \/ globalSpread) + R.random_int(0, 2)) % colors.slice(0, 12).length;\n        } else if (colorStyle == \"allSolid\" || colorStyle == \"allSolidGreyWhite\") {\n            col = randomColorA;\n        } else if (colorStyle == \"splitTwo\") {\n            if (i < totalLinesToBeStitched \/ 2) {\n                col = slash % 2 == 0 ? randomColorA : randomColorB;\n            } else {\n                col = slash % 2 == 0 ? randomColorB : randomColorA;;\n            }\n        } else if (colorStyle == \"splitAll\") {\n            if (i < totalLinesToBeStitched \/ 2) {\n                col = slash % 2 == 0 ? (randomColorA + localSpread) % colors.slice(0, 12).length : (randomColorB + localSpread) % colors.slice(0, 12).length;\n            } else {\n                col = slash % 2 == 0 ? (randomColorB + localSpread) % colors.slice(0, 12).length : (randomColorA + localSpread) % colors.slice(0, 12).length;;\n            }\n        } else if (colorStyle == \"biColorGrad\") {\n            let colorPicker = R.random_dec(0, 1);\n            if (colorPicker < slash \/ (numSlashes - 1)) {\n                col = randomColorA;\n            } else {\n                col = randomColorB;\n            }\n        } else {\n            col = 13;\n        }\n\n        slashInsideColors.push(col);\n\n        let thisRowA = [];\n\n        colors[col].orderValue++;\n        let v1 = createVector(a[0], a[1]);\n        let v1b = createVector(d[0], a[1]);\n        let v2 = lineOrientation == \"h\" ? createVector(b[0], b[1]) : createVector(d[0], d[1]);\n        let midPointA = p5.Vector.lerp(v1, v2, 0.5);\n        let v3 = lineOrientation == \"h\" ? createVector(d[0], d[1]) : createVector(b[0], b[1]);\n        let v3b = createVector(c[0], b[1]);\n        let v4 = createVector(c[0], c[1]);\n        let midPointB = p5.Vector.lerp(v3, v4, 0.5);\n        let posA = (i < totalLinesToBeStitched \/ 2 && arrow) ? p5.Vector.lerp(v1b, midPointA, i * incrementA * 2) : p5.Vector.lerp(v1, v2, i * incrementA);\n        let posB = (i < totalLinesToBeStitched \/ 2 && arrow) ? p5.Vector.lerp(v3b, midPointB, i * incrementA * 2) : p5.Vector.lerp(v3, v4, i * incrementA);\n\n\n\n        for (let j = 0; j < totalStitchesAcross; j++) {\n            let v5 = lineOrientation == \"h\" ? createVector(posA.x + totalWidth + translateValue - (arrow ? 2 : 0), posA.y) : createVector(posA.x + totalWidth - inset + translateValue - (arrow ? 2 : 0), posA.y);\n            let v6 = lineOrientation == \"h\" ? createVector(posB.x + totalWidth + translateValue - (arrow ? 2 : 0), posB.y) : createVector(posB.x + totalWidth + inset + translateValue - (arrow ? 2 : 0), posB.y);\n            let v7 = p5.Vector.lerp(v5, v6, j == 0 ? incrementB \/ inset : j * incrementB);\n            let v8 = p5.Vector.lerp(v5, v6, j == totalStitchesAcross - 1 ? (j + 1) * incrementB - incrementB \/ inset : (j + 1) * incrementB);\n           \n            thisRowA.push(v7);\n            if (j==totalStitchesAcross-1) thisRowA.push(v8);\n\n        }\n\n        \n        if (colors[col].orderValue % 2 == 0) thisRowA.reverse();\n       \n        let infillPoly = new Poly(thisRowA,0,0,1,0,0);\n        infillPoly.setColorValue(col);\n        polys.push(infillPoly);\n        thisFillStitchCount++;\n        totalFillStitchCount++;\n    }\n\n}\nfunction drawUnderlayment(a, b, c, d, fillLineOrientation, color, arrow) {\n\n\n    let stitchSpacingInMM = underlaymentSpacingInMM;\n    let stitchSpacing = stitchSpacingInMM * MM;\n    let stitchLength = underlaymentStitchLengthInMM * MM;\n    let lineDistX = Math.abs(a[0] - b[0]);\n    let lineDistY = Math.abs(a[1] - d[1]);\n    let lineLength = fillLineOrientation == \"v\" ? dist(a[0], a[1], d[0], d[1]) : lineDistX;\n    let totalLinesToBeStitched = Math.floor((fillLineOrientation == \"v\" ? lineDistX : lineDistY) \/ stitchSpacing);\n    let spaceBetweenLinesToBeStitched = (fillLineOrientation == \"v\" ? lineDistX : lineDistY) \/ totalLinesToBeStitched;\n    let incrementA = spaceBetweenLinesToBeStitched \/ (fillLineOrientation == \"v\" ? lineDistX : lineDistY);\n    let totalStitchesAcross = Math.floor(lineLength \/ stitchLength);\n    let spaceBetweenStitches = lineLength \/ totalStitchesAcross;\n    let incrementB = spaceBetweenStitches \/ lineLength;\n    let allRows = [];\n    for (let i = 1; i <= totalLinesToBeStitched - 1; i++) {\n        let thisRow = [];\n        let thisRowA = [];\n\n        colors[color].orderValue++;\n        let v1 = createVector(a[0], a[1]);\n        let v1b = createVector(d[0], a[1]);\n        let v2 = fillLineOrientation == \"v\" ? createVector(b[0], b[1]) : createVector(d[0], d[1]);\n        let v2b = createVector(c[0], a[1]);\n        let m1 = p5.Vector.lerp(v1, createVector(d[0], d[1]), 0.5);\n        let v3 = fillLineOrientation == \"v\" ? createVector(d[0], d[1]) : createVector(b[0], b[1]);\n        let v4 = createVector(c[0], c[1]);\n        let m2 = p5.Vector.lerp(v2, createVector(c[0], c[1]), 0.5);\n\n        let posA = p5.Vector.lerp(v1, v2, i * incrementA);\n        let posB = p5.Vector.lerp(v3, v4, i * incrementA);\n        let posC = p5.Vector.lerp(v1b, v2b, i * incrementA);\n        let posD = p5.Vector.lerp(m1, m2, i * incrementA);\n\n        for (let j = 0; j < totalStitchesAcross; j++) {\n            let v5 = (j < totalStitchesAcross \/ 2 && arrow) ? createVector(posC.x + totalWidth + translateValue - 2, posC.y) : arrow ? createVector(posA.x + totalWidth + translateValue - 2, posA.y) : createVector(posA.x + totalWidth + translateValue, posA.y);\n            let v6 = (j < totalStitchesAcross \/ 2 && arrow) ? createVector(posD.x + totalWidth + translateValue - 2, posD.y) : arrow ? createVector(posB.x + totalWidth + translateValue - 2, posB.y) : createVector(posB.x + totalWidth + translateValue, posB.y);\n            let v7 = p5.Vector.lerp(v5, v6, j * incrementB * (j < totalStitchesAcross \/ 2 && arrow ? 2 : 1));\n            let v8 = p5.Vector.lerp(v5, v6, (j + 1) * incrementB * (j < totalStitchesAcross \/ 2 && arrow ? 2 : 1));\n            \n            let p1a = (colors[color].orderValue % 2 == 0)?[v8,v7]:[v7,v8];\n\n           \n            thisRowA.push(v7);\n            if (j==totalStitchesAcross-1) thisRowA.push(v8);\n\n        }\n\n        \n\n        \n        if (colors[color].orderValue % 2 == 0) thisRowA.reverse();\n        for (let z = 0;z<thisRowA.length;z++){\n            allRows.push(thisRowA[z]);\n        }\n      \n        \n\n    }\n    \n    let underlaymentPoly = new Poly(allRows,0,0,1,0,0);\n   \n    underlaymentPoly.setColorValue(color);\n    polys.push(underlaymentPoly);\n    \n}\n\nfunction drawArrowBorder(slash) {\n    beginShape();\n    if (arrow) {\n        vertex(vertices[slash][3][0] + totalWidth + translateValue, vertices[slash][0][1]);\n        vertex(vertices[slash][2][0] + totalWidth + translateValue, vertices[slash][0][1]);\n        let v1 = createVector(vertices[slash][1][0] + totalWidth + translateValue, vertices[slash][1][1]);\n        let v2 = createVector(vertices[slash][2][0] + totalWidth + translateValue, vertices[slash][2][1]);\n        let midpoint1 = p5.Vector.lerp(v1, v2, 0.5);\n        vertex(midpoint1.x, midpoint1.y);\n        vertex(vertices[slash][2][0] + totalWidth + translateValue, vertices[slash][2][1]);\n        vertex(vertices[slash][3][0] + totalWidth + translateValue, vertices[slash][3][1]);\n        let v3 = createVector(vertices[slash][0][0] + totalWidth + translateValue, vertices[slash][0][1]);\n        let v4 = createVector(vertices[slash][3][0] + totalWidth + translateValue, vertices[slash][3][1]);\n        let midpoint2 = p5.Vector.lerp(v3, v4, 0.5);\n        vertex(midpoint2.x, midpoint2.y);\n    } else {\n        for (let i = 0; i < vertices[slash].length; i++) {\n            vertex(vertices[slash][i][0] + totalWidth + translateValue, vertices[slash][i][1]);\n        }\n    }\n    endShape(CLOSE);\n}\n\n\nfunction drawFillLines(a, b, c, d, spacing, lineOrientation, slash, arrow) {\n\n    if (angle > 0 && lineOrientation == \"h\") spacing = spacing * (0.6 + angle);\n    let stitchSpacingInMM = spacing;\n    let stitchSpacing = stitchSpacingInMM * MM;\n    let lineDistX = Math.abs(a[0] - b[0]);\n    let lineDistY = Math.abs(a[1] - d[1]);\n    let totalLinesToBeStitched = Math.floor((lineOrientation == \"h\" ? lineDistX : lineDistY) \/ stitchSpacing);\n    let spaceBetweenLinesToBeStitched = (lineOrientation == \"h\" ? lineDistX : lineDistY) \/ totalLinesToBeStitched;\n    let incrementA = spaceBetweenLinesToBeStitched \/ (lineOrientation == \"h\" ? lineDistX : lineDistY);\n\n\n    for (let i = 1; i <= totalLinesToBeStitched - 1; i++) {\n        let finishLineChance = R.random_num(0,1);\n        let col;\n        col = partyMode ? (slashInsideColors[totalCount] + Math.floor(frCount \/ 2)) % 12 : slashInsideColors[totalCount];\n\n        if (finishLine==true && finishLineChance<0.05 && frCount%3==0 ){\n           col= col==12?13:12;\n        }\n\n        let v1 = createVector(a[0], a[1]);\n        let v1b = createVector(d[0], a[1]);\n        let v2 = lineOrientation == \"h\" ? createVector(b[0], b[1]) : createVector(d[0], d[1]);\n        let midPointA = p5.Vector.lerp(v1, v2, 0.5);\n        let v3 = lineOrientation == \"h\" ? createVector(d[0], d[1]) : createVector(b[0], b[1]);\n        let v3b = createVector(c[0], b[1]);\n        let v4 = createVector(c[0], c[1]);\n        let midPointB = p5.Vector.lerp(v3, v4, 0.5);\n        let posA = (i < totalLinesToBeStitched \/ 2 && arrow) ? p5.Vector.lerp(v1b, midPointA, i * incrementA * 2) : p5.Vector.lerp(v1, v2, i * incrementA);\n        let posB = (i < totalLinesToBeStitched \/ 2 && arrow) ? p5.Vector.lerp(v3b, midPointB, i * incrementA * 2) : p5.Vector.lerp(v3, v4, i * incrementA);\n\n        stroke(colors[col].rgb);\n        strokeWeight(1);\n        let v5 = createVector(posA.x + totalWidth + translateValue, posA.y);\n        let v6 = createVector(posB.x + totalWidth + translateValue, posB.y);\n        line(v5.x, v5.y, v6.x, v6.y);\n        let lineSegments = [];\n        let numNodes = lineOrientation == \"v\" ? 100 : 200;\n        for (let i = 0; i <= numNodes; i++) {\n            lineSegments.push(p5.Vector.lerp(v5, v6, i \/ numNodes));\n        }\n        if (noiseMode) {\n            let newColor = shadeColor(colors[col].rgb, -40);\n            newColor.push(noiseAlpha<80?Math.floor(noiseAlpha):80);\n            stroke(newColor);\n            strokeWeight(0.33);\n            beginShape();\n\n            for (let j = 0; j <= numNodes; j++) {\n                vertex(lineSegments[j].x - (lineOrientation == \"h\" ? 0.55 : 0) + R.random_num(0, 1.1), lineSegments[j].y - (lineOrientation == \"h\" ? 0 : 0.55) + R.random_num(0, 1.1));\n            }\n            endShape();\n        }\n\n        totalCount++;\n        noiseAlpha = noiseAlpha + frCount\/2000;\n    }\n\n}\n\nfunction keyPressed() {\n    if (keyCode === 83) {\n        saveMyPNG();\n    } else if (keyCode === 69) {\n        saveMySVG(embroiderySizeW, embroiderySizeH);\n    } else if (keyCode === 13) {\n        if (partyMode == false) {\n            partyMode = true;\n        } else {\n            partyMode = false;\n        }\n    } else if (keyCode === 78) {\n        if (noiseMode == false) {\n            noiseMode = true;\n        } else {\n            noiseMode = false;\n        }\n    } else if (keyCode === 32) {\n        if (backgroundColor == 255) {\n            backgroundColor = 0;\n        } else {\n            backgroundColor = 255;\n        }\n    } else if (keyCode === 79) {\n        if (outlineMode == false) {\n            outlineMode=true;\n        } else {\n            outlineMode = false;\n        }\n    } else if (keyCode === 70) {\n        if (finishLine == false) {\n            finishLine=true;\n        } else {\n            finishLine = false;\n        }\n    } else if (keyCode === 76) {\n        if (lonely == false){\n            forPrint=false;\n            lonely=true;\n            resizeCanvas(window.innerWidth,window.innerHeight);\n            let smallerDim = Math.min(window.innerWidth,window.innerHeight);\n            scaler=smallerDim\/(embroiderySizeW*2);\n        } else {\n            lonely=false;\n            forPrint=false;\n            resizeCanvas(window.innerWidth,window.innerHeight);\n            let smallerDim = Math.min(width, height) == width ? width : height;\n            scaler = smallerDim \/ (smallerDim == width ? embroiderySizeW : embroiderySizeH * 2);\n        }\n    } else if (keyCode==80) {\n        if (forPrint==false){\n            lonely=false;\n            forPrint=true;\n            let smallerDim = Math.min(window.innerWidth,window.innerHeight);\n            resizeCanvas(smallerDim,smallerDim);\n            scaler=smallerDim\/(embroiderySizeW*2);\n        } else {\n            forPrint=false;\n            lonely=false;\n            resizeCanvas(window.innerWidth,window.innerHeight);\n            let smallerDim = Math.min(width, height) == width ? width : height;\n            scaler = smallerDim \/ (smallerDim == width ? embroiderySizeW : embroiderySizeH * 2);\n        }\n    } else if (keyCode==192) {\n        alert(\"\/\/\/ is dedicated to my dad who ignited my passion for cars and racing at a very young age.\")\n    }\n}\n\n\nfunction drawParallelogram(x1, y1, base, ht, angle) {\n\n    let dx = ht * tan(angle);\n\n    let x2 = x1 + base;\n    let y2 = y1;\n\n    let x3 = x1 + dx\n    let y3 = y1 - ht;\n\n    let x4 = x1 + base + dx;\n    let y4 = y1 - ht;\n\n\n    return [\n        [x3, y3],\n        [x4, y4],\n        [x2, y2],\n        [x1, y1],\n        [x3, y3]\n    ]; \/\/ Looping back to the start\n}\n\nfunction generateEmbroiderySVG(embroiderySizeW, embroiderySizeH) {\n\n    return createSVGCanvas(embroiderySizeW, embroiderySizeH, false);\n\n}\n\nfunction shadeColor(color, percent) {\n\n    let r = color[0] * (100 + percent) \/ 100;\n    let g = color[1] * (100 + percent) \/ 100;\n    let b = color[2] * (100 + percent) \/ 100;\n\n    r = (r < 255) ? r : 255;\n    g = (g < 255) ? g : 255;\n    b = (b < 255) ? b : 255;\n\n    return [Math.round(r), Math.round(g), Math.round(b)];\n}"
}