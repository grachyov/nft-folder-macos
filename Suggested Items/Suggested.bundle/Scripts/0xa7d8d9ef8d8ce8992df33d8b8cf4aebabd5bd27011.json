{
  "kind" : "p5js100",
  "screensaverFileName" : "HyperHash",
  "value" : "let hashPairs = [];\n\nfor (let j = 0; j < 32; j++) {\n     hashPairs.push(tokenData.hash.slice(2 + (j * 2), 4 + (j * 2)));\n}\n\nlet decPairs = hashPairs.map(x => {\n     return parseInt(x, 16);\n});\n\nlet mainShader;\nlet a_Particles = 6;\nlet particles = [];\n\n\/\/inputParameters\nlet layers = 4;\nlet layerData = [];\nlet colorBase = 0;\nlet colorRange = 0;\nlet colorFrequency = 0;\nlet colorSpeed = 0;\nlet rotationspeeds = [];\nlet mirror = 0;\nlet warp = 0;\nlet phase = 0;\nlet volume = 0;\nlet timer = 0;\nlet checkFrameTime = 0;\nlet rare = 0;\n\nfunction preload() {\n     randomFromHash();\n     mainShader = getShader(this._renderer);\n}\n\nfunction setup() {\n\n     createCanvas(windowWidth, windowHeight, WEBGL);\n     shader(mainShader);\n     mainShader.setUniform(\"colorBase\", colorBase);\n     mainShader.setUniform(\"colorRange\", colorRange);\n     mainShader.setUniform(\"colorFrequency\", colorFrequency);\n     mainShader.setUniform(\"colorSpeed\", colorSpeed);\n     mainShader.setUniform(\"mirror\", mirror);\n     mainShader.setUniform(\"warp\", warp);\n     mainShader.setUniform(\"phase\", phase);\n     mainShader.setUniform(\"rare\", rare);\n     setupParticles();\n\n}\n\nfunction draw() {\n\n     var data = [];\n\n     for (let p of particles) {\n          p.move();\n          data.push(p.x, p.y);\n     }\n\n     mainShader.setUniform('resolution', [width \/ 1000, height \/ 1000])\n     mainShader.setUniform(\"data\", data);\n     mainShader.setUniform(\"time\", phase + millis() \/ 1000.0);\n     rect(0, 0, width, height);\n\n}\n\nfunction randomFromHash() {\n     layers = round(map(decPairs[0], 0, 255, 1, 3));\n     colorBase = map(decPairs[1 + layers + 1], 0, 255, 0.0, 1.0);\n     colorRange = map(decPairs[1 + layers + 2], 0, 255, 0.0, 0.35);\n     if (decPairs[1 + layers + 2] % 50 == 1) {\n          colorRange = 1.5;\n     }\n     colorFrequency = map(decPairs[1 + layers + 3], 0, 255, 1.0, 10.0);\n     colorSpeed = map(decPairs[1 + layers + 4], 0, 255, 0.1, 1.0);\n     phase = map(decPairs[1 + layers + 5], 0, 255, 0.0, 1.0);\n     timer += phase;\n     warp = round(map(decPairs[1 + layers + 6], 0, 255, 1.0, 9.0));\n     mirror = round(map(decPairs[1 + layers + 7], 0, 255, 0.0, 5.0));\n     if (decPairs[1 + layers + 8] % 25 == 3) {\n          rare = 1;\n     }\n     layerData = [];\n     let count = 0;\n     for (let i = 0; i < layers; i++) {\n\n\n          let ranParticles = round(map(decPairs[1 + i], 0, 255, 1, 6));\n          let ranSpeed = map(decPairs[1 + i], 0, 255, 0.05, 0.5);\n          rotationspeeds.push(ranSpeed);\n\n          layerData.push(ranParticles)\n          count += layerData[i];\n     }\n     a_Particles = count;\n\n\n}\n\nfunction Particle(x, y, id, dis, t, l, m) {\n\n     this.xOrg = x;\n     this.yOrg = y;\n     this.x = x;\n     this.y = y;\n     this.id = id;\n     this.dis = dis;\n     this.theta = t;\n     this.layer = l;\n     this.mul = m;\n     this.move = function() {\n\n          timer = millis() \/ 1000.0;\n          timer *= rotationspeeds[this.layer];\n          this.x = (this.mul * (this.layer + 1) * cos(this.theta + PI \/ 2 + timer));\n          this.y = (this.mul * (this.layer + 1) * sin(this.theta + PI \/ 2 + timer));\n\n     }\n}\n\nfunction setupParticles() {\n     let count = 0;\n\n     for (let j = 0; j < layers; j++) {\n\n          let mul = 0.3 \/ layerData.length;\n          for (let o = 0; o < layerData[j]; o++) {\n               count += 1;\n               let theta = map(o, 0, layerData[j], -PI, PI);\n               let x = (mul * (j + 1) * cos(theta + PI \/ 2));\n               let y = (mul * (j + 1) * sin(theta + PI \/ 2));\n               particles.push(new Particle(x, y, count, mul * (j + 1), theta, j, mul));\n          }\n\n     }\n\n}\n\n\nfunction getShader(_renderer) {\n     const vert = `\n\t\tattribute vec3 aPosition;\n\t\tattribute vec2 aTexCoord;\n\n\t\tvarying vec2 vTexCoord;\n\n\t\tvoid main() {\n\t\t\tvTexCoord = aTexCoord;\n\n\t\t\tvec4 positionVec4 = vec4(aPosition, 1.0);\n\t\t\tpositionVec4.xy = positionVec4.xy * 2.0 - 1.0;\n\n\t\t\tgl_Position = positionVec4;\n\t\t}\n\t`;\n\n     const frag = `\n\t\tprecision highp float;\n\n\t\tvarying vec2 vTexCoord;\n\t\t#define pi 3.14159265359\n\n\t\tuniform vec2 data[${a_Particles}];\n\t\n\t\tconst float WIDTH = ${windowWidth}.0;\n\t\tconst float HEIGHT = ${windowHeight}.0;\n\n\t\tuniform vec2 resolution;\n\t\t\n\t\tuniform float time;\n\t\tuniform float colorBase;\n\t\tuniform float colorRange;\n\t\tuniform float colorFrequency;\n\t\tuniform float colorSpeed;\n\t\tuniform float warp;\n\t\tuniform float mirror;\n\t\tuniform float volume;\n\t\tuniform float rare;\n\n\n\t\tmat2 rotate2d(float _angle){\n    \t\treturn mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n\t\t}\n\n\t\tvec3 hsv2rgb(vec3 c) {\n\t\t\t\tvec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n\t\t\t\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\t\t\t\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n\t\t}\n\n\t\tfloat comPower(vec2 pos, float amp1, float amp2){\n\t\t\t\n\t\t\tfloat dis = 0.0; \n\t\n\t\t\tfor (int i = 0; i < ${a_Particles}; i++) {\n\t\t\t\tvec2 particle = data[i];\n\t\t\t\tfloat d = distance(pos, particle);\n\t\t\t\tfloat d1 = 1.-smoothstep(0.0,0.17,fract(d*2. -time*0.05));\n\t\t\t\tdis = max(d1,dis);\n\t\t\t}\n\n\t\t\tfloat disL = fract(dis*10. );\n\t\t\tdisL = step(0.5,disL)-step(0.56,disL);\n\t\t\tdisL *= smoothstep(0.0,0.8,dis);\n\t\t\treturn dis+disL*0.1;\n\t\t}\n\n\t\tvec2 kaleido(vec2 uv,float warp)\n\t\t{\n\n\t\t    float r = length(uv);\n\t\t    float angle = atan(uv.y, uv.x);\n\t\t    \n\t\t    float slices = warp;\n\t\t    float slice = 6.28 \/ slices;\n\n\t\t    angle = mod(angle, slice);\n\t\t    angle = abs(angle - 0.5 * slice);\n\t\t   \n\t\t    \n\t\t    uv = vec2(cos(angle), sin(angle)) * r;\n\t\t\t\treturn uv;\n\t\t}\n\n\t\tfloat drawLine (vec2 p1, vec2 p2, vec2 uv,float a)\n\t\t{\n\t\t\tfloat scaler = sin(time*0.1);\n\n\t\t    float r = 0.;\n\t\t    float one_px = 1. \/WIDTH; \n\n\t\t    float d = distance(p1, p2);\n\n\t\t    float duv = distance(p1, uv);\n\n\t\t    float rel = clamp(duv \/ d, 0., 1.);\n\t\t    vec2 lerp = mix(p1, p2, rel);\n\t\t    float disLerp = distance(lerp, uv);\n\t\t    float blur = 1.-smoothstep(0.0,a,disLerp);\n\n\t\t    return blur;\n\t\t}\n\n\t\tfloat particle(vec2 pos){\n\t\t\tfloat dis = 0.0; \n\t\t\tfloat l = 0.;\n\t\t\tfor (int i = 0; i < ${a_Particles}; i++) {\n\t\t\t\tvec2 particle = data[i];\n\t\t\t\tvec2 particle2 = vec2(0.,0.);\n\t\t\t\tif(i<${a_Particles}-1){\n\t\t\t\t\tparticle2 = data[i+1];\n\t\t\t\t}else{\n\t\t\t\t\tparticle2 = data[0];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat d = distance(pos, particle);\n\t\t\t\td = 1.-smoothstep(0.,0.1,d);\n\t\t\t\tdis = max(d,dis);\n\t\t\t\tfloat lt = 0.003;\n\t\t\t\tl += drawLine(particle,particle2 ,pos,lt);\n\t\t\t\tl += drawLine(particle,vec2(0.) ,pos,lt);\n\t\t\t\t\n\t\t\t}\n\n\t\t\treturn (dis*0.5) + (l);\/\/(dis *l)\n\t\t}\n\n\t\tfloat rand(vec2 co){\n    \t\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\t}\n\n\t\tvoid main() {\n\t\t\t\n\t\t\tfloat rel = WIDTH\/HEIGHT;\n\t\t\tvec2 st = vTexCoord.xy - 0.5;\n\t\t\tst.x *=rel;\n\n\t\t\tif(mirror == 0.){\t\n\t\t\t\tst.x = abs(st.x);\n\t\t\t}\n\t\t\tif(mirror == 1.){\t\n\t\t\t\tst.y = abs(st.y);\n\t\t\t}\t\n\n\t\t\tif(mirror == 2.){\n\t\t\t\tst.x = abs(st.x);\t\n\t\t\t\tst.y = abs(st.y);\n\t\t\t}\t\n\t\t\tif(mirror == 3.){\n\t\t\tst = kaleido(st,warp);\n\n\t\t\t}\t\n\n\t\t\tfloat dis = 1.-distance(st,vec2(0.));\n\n\t\t  st = rotate2d( sin(time*0.2+dis*2.)* (1.-dis) ) * st; \/\/\n\n\t\t\tfloat comPow = comPower(st,1.,1.);\n\t\t\t\n\t\t\tfloat fade = smoothstep(0.4,0.7,dis);\n\t\t  \n\t\t\tfloat outdis = step(0.598,dis);\n\t\t\toutdis -= step(0.6,dis);\n\t\t\tvec3 outerLayer = vec3(outdis);\n\t\t\t\n\t\t\tvec3 par = vec3(particle(st));\n\t\t\t\n\t\t\tfloat flowSine = (sin(dis*5.+time)+1.)\/2.;\n\t\t\tflowSine *= 0.2;\n\t\t\tflowSine += 0.05;\n\t\t\tvec3 dot = vec3(1.-step(0.003,1.-dis));\n\t\t\tfloat colorSine = (1.+sin(time*colorSpeed+(dis*colorFrequency)))\/2.;\n\t\t\tcolorSine = colorBase+(colorSine*colorRange);\n\t\t\tvec3 gradient = hsv2rgb(vec3(colorSine,1.0,0.8));\n\t\t\tvec3 powerBack = (vec3(comPow)*gradient*0.7) + (gradient*(0.3)) + (gradient*par +par*0.3*(volume*15.)); \n\n\t\t\tvec3 comb = 0.3+(powerBack*0.7 );\n\t\t\n\t\t\tif(rare == 0.){\n\t\t\t\tgl_FragColor = vec4(comb, 1.0);\n\t\t\t}else{\n\t\t\t\tgl_FragColor = vec4(vec3((comb.x+comb.y+comb.z)\/3.), 1.0);\n\t\t\t}\n\t\t  \n\t\t\t\n\t\t}\n\t`;\n\n     return new p5.Shader(_renderer, vert, frag);\n}"
}