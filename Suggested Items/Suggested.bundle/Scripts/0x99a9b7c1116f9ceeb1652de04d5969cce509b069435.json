{
  "kind" : "p5js100",
  "screensaverFileName" : "Flows",
  "value" : "class Random {\n  constructor() {\n    this.useA = false;\n    let sfc32 = function (uint128Hex) {\n      let a = parseInt(uint128Hex.substr(0, 8), 16);\n      let b = parseInt(uint128Hex.substr(8, 8), 16);\n      let c = parseInt(uint128Hex.substr(16, 8), 16);\n      let d = parseInt(uint128Hex.substr(24, 8), 16);\n      return function () {\n        a |= 0;\n        b |= 0;\n        c |= 0;\n        d |= 0;\n        let t = (((a + b) | 0) + d) | 0;\n        d = (d + 1) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        c = (c + t) | 0;\n        return (t >>> 0) \/ 4294967296;\n      };\n    };\n    \/\/ seed prngA with first half of tokenData.hash\n    this.prngA = new sfc32(tokenData.hash.substr(2, 32));\n    \/\/ seed prngB with second half of tokenData.hash\n    this.prngB = new sfc32(tokenData.hash.substr(34, 32));\n    for (let i = 0; i < 1e6; i += 2) {\n      this.prngA();\n      this.prngB();\n    }\n  }\n  \/\/ random number between 0 (inclusive) and 1 (exclusive)\n  random_dec() {\n    this.useA = !this.useA;\n    return this.useA ? this.prngA() : this.prngB();\n  }\n  \/\/ random number between a (inclusive) and b (exclusive)\n  random_num(a, b) {\n    return a + (b - a) * this.random_dec();\n  }\n  \/\/ random integer between a (inclusive) and b (inclusive)\n  \/\/ requires a < b for proper probability distribution\n  random_int(a, b) {\n    return Math.floor(this.random_num(a, b + 1));\n  }\n  \/\/ random boolean with p as percent liklihood of true\n  random_bool(p) {\n    return this.random_dec() < p;\n  }\n}\nlet R = new Random();\n\n\/\/ define and preload stream shader\nlet stream;\nlet vertexShader = `\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 pos;\n\nvoid main() {\n  \/\/ copy the texcoords\n  pos = aTexCoord;\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  positionVec4.xy = positionVec4.xy * 2.0 - 1.0;\n  gl_Position = positionVec4;\n}\n`;\nlet fragmentShader = `\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec2 pos;\nuniform sampler2D texture;\n\n\/\/ multiplier to scale to screen size\nuniform vec2 M;\n\/\/ ratios of screen dims to base dims\nuniform vec2 Sxy;\n\/\/ pixel density of display\nuniform float D;\n\/\/ screen values to calculate offsets later\nuniform float OFFSETX;\nuniform float OFFSETY;\n\n\/\/ stream function\nuniform float psiMult;\nuniform float psiOffset;\nuniform bool useDivergenceInPsi;\n\/\/ velocity potential\nuniform float phiMult;\nuniform float phiOffset;\nuniform bool useVorticityInPhi;\n\nconst int maxElements = 14;\nuniform int activeElements;\nuniform float elementsX[14];\nuniform float elementsY[14];\nuniform float vortexStrengths[14];\nuniform float divergences[14];\n\nuniform int paletteIndex;\nuniform bool limitHueMatlab;\n\nuniform float hueStaticOffset;\nuniform bool migraine;\nuniform float saturation;\n\n\/\/ gets stream and velocity potential function values\n\/\/ @dev all calculations in base coordinates\nvec2 getPsiPhi(vec2 bc) {\n  float psi = 0.0;\n  float phi = 0.0;\n  \/\/ flow elements\n  for (int i = 0; i < maxElements; i++) {\n    if (i >= activeElements) {\n      break;\n    }\n    float r = distance(bc, vec2(elementsX[i], elementsY[i]));\n    float theta = atan((bc.y - (elementsY[i])), (bc.x - (elementsX[i])));\n    \/\/ vorticity\n    psi = psi + (1.0 * vortexStrengths[i]) * log(r);\n    if (useVorticityInPhi) {\n      phi = phi + vortexStrengths[i] * theta;\n    } else {\n      if (vortexStrengths[i] < 0.0) {\n        phi = phi + theta;\n      } else {\n        phi = phi - theta;\n      }\n    }\n    \/\/ divergence (source\/sink)\n    if (useDivergenceInPsi) {\n      psi = psi + divergences[i] * theta;\n    } else {\n      \/\/ already added theta in vorticity section\n    }\n    phi = phi - divergences[i] * log(r);\n  }\n  \/\/ uniform flow not utilized in this project\n  return vec2(psi, phi);\n}\n\/\/ gets velocity magnitude\n\/\/ @dev all calculations in base coordinates\nfloat getVelocityMagnitude(vec2 bc) {\n  float u = 0.0;\n  float v = 0.0;\n  \/\/ flow elements\n  for (int i = 0; i < maxElements; i++) {\n    if (i >= activeElements) {\n      break;\n    }\n    float r = distance(bc, vec2(elementsX[i], elementsY[i]));\n    float theta = atan((bc.y - (elementsY[i])), (bc.x - (elementsX[i])));\n    \/\/ vorticity\n    float vTheta = vortexStrengths[i] \/ r;\n    u = u + vTheta * cos(theta);\n    v = v + vTheta * sin(theta);\n    \/\/ divergence (source\/sink)\n    float vR = divergences[i] \/ r;\n    u = u + vR * cos(theta + 3.14159 \/ 2.0);\n    v = v + vR * sin(theta + 3.14159 \/ 2.0);\n  }\n  \/\/ uniform flow not utilized in this project\n  return sqrt(u * u + v * v);\n}\n\n\/\/ standard shader rgb2hsv and hsv2rgb functions\nvec3 rgb2hsv(vec3 c) {\n  vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  \/\/ get virtual screen texture at pos\n  vec2 uv = pos;\n  vec4 screenCol = texture2D(texture, uv);\n  \/\/ translate from pos to intermediate coordinates independent of pixel density\n  vec2 ic = gl_FragCoord.xy \/ (M) \/ vec2(D);\n  float noiseOffset = 0.0;\n  \/\/ scale from intermediate to base coordinates\n  vec2 bc = vec2(ic);\n  bc.x = bc.x - 0.5 - (OFFSETX \/ (Sxy.y)) + sin(noiseOffset) * noiseOffset;\n  bc.y = bc.y + 0.5 - (OFFSETY \/ (Sxy.x)) + cos(noiseOffset) * noiseOffset;\n\n  \/\/ calculate stream function and velocity potential in base coordinates\n  vec2 psiPhi = getPsiPhi(bc);\n  float psi = psiPhi.x;\n  float phi = psiPhi.y;\n\n  \/\/ initialize variables\n  float i;\n  float j; \n  vec3 flowFieldColor;\n  vec3 particleColor;\n  \/\/ assign colors based on palette\n  if (paletteIndex == 0) {\n    \/\/ Inclusion\n    i = sin(psi * psiMult + psiOffset);\n    j = cos(phi * phiMult + phiOffset);\n    flowFieldColor = vec3(j - i, j - i, i - j);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    flowFieldHSV = vec3(flowFieldHSV.r, 1.3 - abs(j) \/ 2.0, flowFieldHSV.b);\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    float limit = 0.5;\n    if (flowFieldHSV.b < limit) {\n      flowFieldHSV.g = 0.0;\n      flowFieldHSV.b = limit;\n    } else {\n      flowFieldHSV.b = limit + 3.0 * (flowFieldHSV.b - limit);\n    }\n    particleColor = hsv2rgb(vec3(flowFieldHSV.r, flowFieldHSV.g, flowFieldHSV.b));\n  } else if (paletteIndex == 1) {\n    \/\/ Rainbow\n    i = cos(psi * psiMult + psiOffset \/ 4.0) * 0.2;\n    j = cos(phi * phiMult + phiOffset \/ 4.0) * 0.2;\n    flowFieldColor = hsv2rgb(vec3(fract((i + j) \/ 2.0 * 3.1415926535), saturation, 1.0));\n    particleColor = hsv2rgb(vec3(fract((i + j) \/ 2.0 * 3.1415926535), 0.3, 1.0));\n  } else if (paletteIndex == 2) {\n    \/\/ Skip\n    i = cos(psi * psiMult \/ 2.0 + psiOffset);\n    j = sin(phi * phiMult + phiOffset);\n    flowFieldColor = vec3(cos(psi * psiMult \/ 2.0), j, i);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    float s = saturation;\n    if (migraine) {\n      if (i > 0.75) {\n        s = (3.0 + saturation) - (4.0 * i);\n      }\n    }\n    flowFieldHSV = vec3(fract(flowFieldHSV.r + cos(psi * psiMult)), s, 1.0);\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    particleColor = hsv2rgb(vec3(flowFieldHSV.r, min(s, 0.3), 1.0));\n  } else if (paletteIndex == 3) {\n    \/\/ Form\n    i = cos(psi * psiMult + 0.34 * psiOffset);\n    j = cos(phi * phiMult + phiOffset);\n    float i2 = cos(psi * psiMult + 0.44 * psiOffset + fract(j));\n    flowFieldColor = vec3(0, -i + j, -i);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    float v = 1.0 - j;\n    float h = flowFieldHSV.r + i;\n    float s = saturation;\n    if (j < 0.0) {\n      v = 0.7 - 0.5 + 0.5 * i2;\n      s = 0.2 + 0.5 - 0.5 * i2;\n      h = fract(0.5 * j + 0.25 * i + psiOffset * 0.11);\n    }\n    flowFieldHSV = vec3(h, s, v);\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    if (j < 0.0) {\n      flowFieldHSV.g = saturation - 0.2;\n      flowFieldHSV.b = 1.0;\n    }\n    particleColor = hsv2rgb(flowFieldHSV);\n  } else if (paletteIndex == 4) {\n    \/\/ Overload\n    i = cos(psi * psiMult + 0.94 * psiOffset);\n    j = cos(phi * phiMult + phiOffset);\n    flowFieldColor = vec3(0, -i + j, -i);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    float v = 1.0 - j;\n    if (j > 0.0) {\n      v = abs(i + j);\n    } else {\n      v = 1.0;\n    }\n    flowFieldHSV = vec3(flowFieldHSV.r + i, saturation, v);\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    if (j < 0.0) {\n      flowFieldHSV.g = saturation - 0.2;\n      flowFieldHSV.b = 1.0;\n    }\n    particleColor = hsv2rgb(flowFieldHSV);\n  } else if (paletteIndex == 5) {\n    \/\/ Step\n    i = cos(psi * 6.0 + psiOffset \/ 10.0) * 0.2;\n    j = cos(phi + phiOffset \/ 10.0);\n    flowFieldColor = vec3(i, j + 0.85, 0.0);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    flowFieldHSV.r = flowFieldHSV.r + cos(psi * psiMult + psiOffset \/ 10.0);\n    flowFieldHSV.g = flowFieldHSV.g * 0.75;\n    flowFieldHSV.b = flowFieldHSV.b * 0.5;\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    particleColor = hsv2rgb(vec3(flowFieldHSV.r, flowFieldHSV.g - 0.1, flowFieldHSV.b + 0.1));\n  } else {\n    \/\/ Monochromatic\n    i = cos(psi * psiMult + 0.94 * psiOffset);\n    j = cos(phi * phiMult + phiOffset);\n    float k = cos(phi * phiMult + phiOffset + 3.14);\n    flowFieldColor = vec3(1.0, 0, 0);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    float v;\n    if (j > 0.0) {\n      v = abs(i + j) + fract(0.5 * j + 0.25 * i + 0.5 + psiOffset * 0.11);\n    } else {\n      v = abs(k);\n    }\n    float actualStaticOffset = floor(hueStaticOffset * 6.0) \/ 6.0;\n    if (abs(actualStaticOffset - 0.5) < 0.01) {\n      actualStaticOffset = 0.6666;\n    }\n    if (abs(actualStaticOffset - 0.8333) < 0.01) {\n      actualStaticOffset = 0.0;\n    }\n    flowFieldHSV = vec3(fract(actualStaticOffset), 0.7, v);\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    if (j < 0.0) {\n      flowFieldHSV.g = saturation - 0.2;\n      flowFieldHSV.b = 1.0;\n    }\n    particleColor = hsv2rgb(flowFieldHSV);\n  } \n  \/\/ POST PROCESSING\n  \/\/ Remap hue from red to blue only, emulating default MATLAB contour plot behavior\n  if (limitHueMatlab) {\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    if (flowFieldHSV.r > 0.5) {\n      flowFieldHSV.r = 0.5 - (flowFieldHSV.r - 0.5);\n    }\n    flowFieldHSV.r = flowFieldHSV.r * 0.666 \/ 0.500;\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    vec3 particleHSV = rgb2hsv(particleColor);\n    if (particleHSV.r > 0.5) {\n      particleHSV.r = 0.5 - (particleHSV.r - 0.5);\n    }\n    particleHSV.r = particleHSV.r * 0.666 \/ 0.500;\n    particleColor = hsv2rgb(particleHSV);\n  }\n\n  \/\/ DRAW\n  if (screenCol.r < 0.05) {\n    \/\/ DRAW FLOW FIELD\n    gl_FragColor = vec4(flowFieldColor, 1.0);\n  } else {\n    \/\/ DRAW PARTICLE\n    gl_FragColor = vec4(mix(particleColor, flowFieldColor, 1.0 - (screenCol.r+screenCol.g) \/ 2.0), 1.0);\n  }\n}\n`;\nconst TARGET_FRAME_RATE = 60;\n\n\/\/ --- COORDINATE SYSTEMS ---\n\/\/ base coordinate system is 1000 x 1000\nvar BASE_SIZE = 1000;\n\/\/ translate to window size\nvar WIDTH = window.innerWidth;\nvar HEIGHT = window.innerHeight;\nvar DIM = Math.min(WIDTH, HEIGHT);\nvar S = DIM \/ BASE_SIZE;\nvar SX = WIDTH \/ BASE_SIZE;\nvar SY = HEIGHT \/ BASE_SIZE;\n\/\/ we center the base coordinate system on the screen\nvar OFFSETX = (WIDTH - DIM) \/ 2;\nvar OFFSETY = (HEIGHT - DIM) \/ 2;\n\n\/\/ utility functions to return window coordinate from base coordinate\nfunction M(value) {\n  return value * S;\n}\nfunction Mx(x) {\n  return x * S + OFFSETX;\n}\nfunction My(y) {\n  return y * S + OFFSETY;\n}\n\n\/\/ --- DEFAULT CONFIGURATION ---\nconst CONFIG = {\n  backCol: [0, 0, 0],\n  numParticles: [350, 1000],\n  probabilityNoParticles: 0.1,\n  \/\/ a multiplier that applies to the particle velocities only\n  numElements: [2, 4],\n  numStaticElements: [2, 3],\n  \/\/ note: vortex strength is circulation \/ 2PI\n  vortexStrengthRange: [-23, 23],\n  vortexStrengthMultiplier: 1,\n  allowZeroVortexStrength: true,\n  useVorticityInPhi: false,\n  \/\/ source\/sink\n  probabilityElementsMayDiverge: 0.9,\n  probabilityElementHasDivergence: 1.0,\n  divergenceRange: [-10, 10],\n  divergenceStrengthMultiplier: 1,\n  allowZeroDivergence: false,\n  useDivergenceInPsi: false,\n  \/\/ other\n  phiMult: [1, 1],\n  \/\/ element positioning\n  elementBorder: 0.1,\n  \/\/ particles\n  particleVelocityMult: 6,\n  maxParticleSpeed: 10,\n  particleFrameChanceOfRespawn: 0.01,\n  respawnRadiusIncrement: 0.05,\n  respawnRadiusDecrement: 0.03,\n  particleStrokeWeights: [1, 3, 5],\n  particleStrokeWeightProbabilities: [0.15, 0.75, 0.1],\n  backgroundAlpha: [10, 40],\n};\n\n\/\/ returns a choice from choices based on probabilities (which must sum to 1)\nfunction getWeightedChoice(choices, probabilities) {\n  let x = R.random_dec();\n  let i = 0;\n  let sum_ = 0.0;\n  while (i < probabilities.length - 1) {\n    sum_ += probabilities[i];\n    if (x < sum_) {\n      break;\n    }\n    i++;\n  }\n  return choices[i];\n}\n\n\/\/ --- COLOR PALETTES ---\nPALETTES = [\n  {\n    name: \"Inclusion\",\n    index: 0,\n    psiMult: [1, 1],\n    psiOffsetMultiplier: [1.0, 1.0],\n    phiOffsetMultiplier: \"equal\",\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n  },\n  {\n    name: \"Rainbow\",\n    index: 1,\n    psiMult: [0.1, 0.1],\n    psiOffsetMultiplier: [0.1, 0.4],\n    phiOffsetMultiplier: \"equal\",\n    saturation: [0.75, 0.85],\n    numStaticElements: [4, 4],\n    noParticles: false,\n    maxParticleSpeed: 5.0,\n  },\n  {\n    name: \"Skip\",\n    index: 2,\n    psiMult: [0.05, 0.1],\n    psiOffsetMultiplier: [0.2, 0.25],\n    phiOffsetMultiplier: \"equal\",\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n    hueStaticOffset: [0.0, 1.0],\n    probabilityMigraine: 0.1,\n    saturation: [0.75, 0.85],\n    limitHueMatlab: true,\n    maxParticleSpeed: 5.0,\n  },\n  {\n    name: \"Form\",\n    index: 3,\n    psiMult: [0.05, 0.1],\n    psiOffsetMultiplier: [0.2, 0.6],\n    phiOffsetMultiplier: \"equal\",\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n    maxParticleSpeed: 5.0,\n    saturation: [0.5, 0.8],\n    probabilityHighFlowElements: 0.15,\n    highFlowElementsRange: [5, 14],\n    limitHueMatlab: true,\n  },\n  {\n    name: \"Overload\",\n    index: 4,\n    psiMult: [0.05, 0.1],\n    psiOffsetMultiplier: [0.04, 0.2],\n    phiOffsetMultiplier: \"equal\",\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n    maxParticleSpeed: 5.0,\n    saturation: [0.5, 0.8],\n    probabilityHighFlowElements: 0.15,\n    highFlowElementsRange: [5, 14],\n  },\n  {\n    name: \"Step\",\n    index: 5,\n    psiMult: [0.03, 0.03],\n    psiOffsetMultiplier: [0.5, 0.5],\n    phiOffsetMultiplier: [1, 1],\n    noParticles: false,\n    alwaysParticles: true,\n    particleVelocityMult: 20.0,\n    maxParticleSpeed: 30.0,\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n    saturation: [0.75, 0.85],\n    limitHueMatlab: true,\n  },\n  {\n    name: \"Monochromatic\",\n    index: 6,\n    psiMult: [0.05, 0.1],\n    psiOffsetMultiplier: [0.04, 0.2],\n    phiOffsetMultiplier: \"equal\",\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n    maxParticleSpeed: 5.0,\n    hueStaticOffset: [0.0, 1.0],\n    probabilityHighFlowElements: 0.2,\n    highFlowElementsRange: [5, 14],\n  },\n];\n\nPALETTE_PROBABILITIES = [\n  0.0, \/\/ 0 Inclusion (only token #21)\n  0.2, \/\/ 1 Rainbow\n  0.1, \/\/ 2 Skip\n  0.2, \/\/ 3 Form\n  0.3, \/\/ 4 Overload\n  0.1, \/\/ 5 Step\n  0.1, \/\/ 6 Monochromatic\n];\n\/\/ determine the color palette\nlet paletteRand = R.random_dec();\nlet paletteIndex = 0;\nlet _sum = 0;\nwhile (paletteRand > _sum) {\n  _sum += PALETTE_PROBABILITIES[paletteIndex];\n  paletteIndex++;\n}\n\/\/ token #21 is always Inclusion\nif (tokenData.tokenId % 1_000_000 == 21) {\n  paletteIndex = 1; \/\/ Inclusion's index plus 1\n}\nlet PALETTE = PALETTES[paletteIndex - 1];\nconsole.log(\"Flows: Token ID = \", tokenData.tokenId.toString());\nconsole.log(\"Flows: Palette = \", PALETTE.name);\n\n\/\/ helper function to get a palette override or default scalar value\nfunction getPaletteOrDefault(propName) {\n  return PALETTE[propName] !== undefined ? PALETTE[propName] : CONFIG[propName];\n}\n\n\/\/ helper function to get random value between two points\nfunction randInterp(range, useParabolic) {\n  let interpDec = R.random_dec();\n  if (useParabolic) {\n    interpDec = interpDec * interpDec;\n  }\n  return range[0] + interpDec * (range[1] - range[0]);\n}\n\n\/\/ initialize the configuration details\nconst potentialParticles = PALETTE.numParticlesOverride\n  ? R.random_int(...PALETTE.numParticlesOverride)\n  : R.random_int(...CONFIG.numParticles);\nconst NUM_PARTICLES = PALETTE.noParticles\n  ? 0\n  : R.random_bool(CONFIG.probabilityNoParticles) && !PALETTE.alwaysParticles\n  ? 0\n  : potentialParticles;\nCONFIG.particleStrokeWeightProbabilities = getPaletteOrDefault(\n  \"particleStrokeWeightProbabilities\"\n);\nif (NUM_PARTICLES > 0) {\n  CONFIG.particleStrokeWeight = getWeightedChoice(\n    CONFIG.particleStrokeWeights,\n    CONFIG.particleStrokeWeightProbabilities\n  );\n  const PARTICLE_SIZE_LABELS = {\n    1: \"Small\",\n    3: \"Normal\",\n    5: \"Large\",\n  };\n  console.log(\n    \"Flows: Particle Size = \",\n    PARTICLE_SIZE_LABELS[CONFIG.particleStrokeWeight]\n  );\n}\nCONFIG.particleVelocityMult = getPaletteOrDefault(\"particleVelocityMult\");\nCONFIG.maxParticleSpeed = getPaletteOrDefault(\"maxParticleSpeed\");\nCONFIG.probabilityElementsMayDiverge = getPaletteOrDefault(\n  \"probabilityElementsMayDiverge\"\n);\nCONFIG.particleFrameChanceOfRespawn = getPaletteOrDefault(\n  \"particleFrameChanceOfRespawn\"\n);\nCONFIG.elementsMayDiverge = R.random_bool(CONFIG.probabilityElementsMayDiverge);\nCONFIG.vortexStrengthRange = getPaletteOrDefault(\"vortexStrengthRange\");\nCONFIG.divergenceRange = getPaletteOrDefault(\"divergenceRange\");\nCONFIG.psiMult = randInterp(PALETTE.psiMult, true);\nCONFIG.phiMult = randInterp(CONFIG.phiMult, true);\nCONFIG.useVorticityInPhi = getPaletteOrDefault(\"useVorticityInPhi\");\nCONFIG.useDivergenceInPsi = getPaletteOrDefault(\"useDivergenceInPsi\");\nCONFIG.backgroundAlpha = randInterp(CONFIG.backgroundAlpha, true);\nCONFIG.psiOffsetMultiplier = randInterp(PALETTE.psiOffsetMultiplier, false);\nif (PALETTE.phiOffsetMultiplier == \"equal\") {\n  CONFIG.phiOffsetMultiplier = CONFIG.psiOffsetMultiplier;\n} else {\n  CONFIG.phiOffsetMultiplier = randInterp(PALETTE.phiOffsetMultiplier, false);\n}\nCONFIG.hueStaticOffset =\n  PALETTE.hueStaticOffset != undefined\n    ? randInterp(PALETTE.hueStaticOffset, false)\n    : 0.0;\nCONFIG.migraine =\n  PALETTE.probabilityMigraine != undefined\n    ? R.random_bool(PALETTE.probabilityMigraine)\n    : false;\nCONFIG.saturation =\n  PALETTE.saturation != undefined ? randInterp(PALETTE.saturation, false) : 0.0;\n\n\/\/ --- ELEMENT CONFIGS ---\nconst ELEMENTS = [];\n\/\/ populate vortex arrays\nlet NUM_ELEMENTS = R.random_int(...CONFIG.numElements);\nif (PALETTE.probabilityHighFlowElements != undefined) {\n  if (R.random_bool(PALETTE.probabilityHighFlowElements)) {\n    NUM_ELEMENTS = R.random_int(...PALETTE.highFlowElementsRange);\n  }\n}\nCONFIG.numStaticElements = getPaletteOrDefault(\"numStaticElements\");\nlet NUM_STATIC_ELEMENTS = Math.min(\n  NUM_ELEMENTS,\n  R.random_int(...CONFIG.numStaticElements)\n);\nif (CONFIG.elementsMayDiverge) {\n  NUM_STATIC_ELEMENTS = NUM_ELEMENTS;\n}\nconsole.log(\"Flows: Num Flow Elements = \", NUM_ELEMENTS.toString());\n\n\/\/ utility function to get target time in seconds since start.\n\/\/ assumes that TARGET_FRAME_RATE is set, and ensures that project's\n\/\/ display is never a function of display actual frame rate\nfunction time_() {\n  try {\n    return frameCount \/ TARGET_FRAME_RATE;\n  } catch (error) {\n    return 0;\n  }\n}\n\nclass Element {\n  constructor(isStatic) {\n    this.initialize();\n    this.isStatic = isStatic;\n  }\n\n  \/\/ sets vorticity, divergene, and initial position of element\n  initialize() {\n    this.respawn();\n    \/\/ assign vorticity\n    let _vortexStrength = 0;\n    while (_vortexStrength === 0) {\n      _vortexStrength = R.random_int(...CONFIG.vortexStrengthRange);\n      if (CONFIG.allowZeroVortexStrength) {\n        break;\n      }\n    }\n    this.vortexStrength = _vortexStrength * CONFIG.vortexStrengthMultiplier;\n    \/\/ assign divergence\n    let _divergence = 0;\n    if (\n      CONFIG.elementsMayDiverge &&\n      R.random_bool(CONFIG.probabilityElementHasDivergence)\n    ) {\n      while (_divergence === 0) {\n        _divergence = R.random_int(...CONFIG.divergenceRange);\n        if (CONFIG.allowZeroDivergence) {\n          break;\n        }\n      }\n    }\n    this.divergence = _divergence * CONFIG.divergenceStrengthMultiplier;\n  }\n\n  _getRandomValidPosition() {\n    return R.random_int(\n      BASE_SIZE * CONFIG.elementBorder,\n      BASE_SIZE * (1 - CONFIG.elementBorder)\n    );\n  }\n\n  \/\/ changes position of element\n  respawn() {\n    this.x = this._getRandomValidPosition();\n    this.y = this._getRandomValidPosition();\n  }\n\n  \/\/ operates in base coordinates\n  getVelocity(_atPosition) {\n    \/\/ get radial distance from vortex to point\n    const r = pointDistance(this.x, this.y, _atPosition[0], _atPosition[1]);\n    if (r === 0) {\n      \/\/ avoid divide by zero, very, very edge case, return zero velocity\n      return [0, 0];\n    }\n    \/\/ calc theta, 90 degrees\n    const theta =\n      Math.PI \/ 2 + pointAngle(this.x, this.y, _atPosition[0], _atPosition[1]);\n    \/\/ --- Vorticity ---\n    const v_theta = this.getVortexStrength() \/ r;\n    \/\/ return velocity in cartesian reference frame, with particle gamma multiplier\n    let vx = v_theta * Math.cos(theta) * CONFIG.particleVelocityMult;\n    let vy = v_theta * Math.sin(theta) * CONFIG.particleVelocityMult;\n    \/\/ --- Source\/Sink ---\n    const v_r = this.getDivergence() \/ r;\n    vx += v_r * Math.cos(theta + Math.PI \/ 2) * CONFIG.particleVelocityMult;\n    vy += v_r * Math.sin(theta + Math.PI \/ 2) * CONFIG.particleVelocityMult;\n    \/\/ --- Uniform Flow not utilized in this project ---\n    return [vx, vy];\n  }\n\n  getVortexStrength() {\n    return this.vortexStrength;\n  }\n\n  getDivergence() {\n    return this.divergence;\n  }\n}\n\n\/\/ populate global elements array\nfor (let i = 0; i < NUM_ELEMENTS; i++) {\n  const _isStatic = i < NUM_STATIC_ELEMENTS;\n  ELEMENTS.push(new Element(_isStatic));\n}\n\n\/\/ shift view to geometric center of all flow elements\nlet centerX = 0;\nlet centerY = 0;\nfor (let i = 0; i < NUM_ELEMENTS; i++) {\n  centerX += ELEMENTS[i].x;\n  centerY += ELEMENTS[i].y;\n}\ncenterX \/= NUM_ELEMENTS;\ncenterY \/= NUM_ELEMENTS;\nfor (let i = 0; i < NUM_ELEMENTS; i++) {\n  ELEMENTS[i].x -= centerX - BASE_SIZE \/ 2;\n  ELEMENTS[i].y -= centerY - BASE_SIZE \/ 2;\n}\n\n\/\/ returns distance between two points\nconst pointDistance = (x1, y1, x2, y2) => {\n  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n};\n\n\/\/ returns angle in radians between two points\nconst pointAngle = (x1, y1, x2, y2) => {\n  return Math.atan2(y2 - y1, x2 - x1);\n};\n\n\/\/ returns velocity [u, v] at a point due to all flow elements.\n\/\/ operates in base coordinates\nfunction getVelocityAtPoint(_position) {\n  let v = [0, 0];\n  for (let i = 0; i < NUM_ELEMENTS; i++) {\n    const elV = ELEMENTS[i].getVelocity(_position);\n    v[0] += elV[0];\n    v[1] += elV[1];\n  }\n  return v;\n}\n\n\/\/ updates position of all non-static vortices.\n\/\/ operates in base coordinates\nfunction updateElementPositions() {\n  DxDy = [];\n  for (let i = 0; i < NUM_ELEMENTS; i++) {\n    const DxDyi = [0, 0];\n    if (!ELEMENTS[i].isStatic) {\n      \/\/ calculate velocity at element due to all other elements\n      for (let j = 0; j < NUM_ELEMENTS; j++) {\n        if (i != j) {\n          const elV = ELEMENTS[j].getVelocity([ELEMENTS[i].x, ELEMENTS[i].y]);\n          DxDyi[0] += elV[0];\n          DxDyi[1] += elV[1];\n        }\n      }\n    }\n    DxDy.push(DxDyi);\n  }\n  \/\/ update positions\n  for (let i = 0; i < NUM_ELEMENTS; i++) {\n    ELEMENTS[i].x += DxDy[i][0];\n    ELEMENTS[i].y += DxDy[i][1];\n  }\n}\n\nclass Particle {\n  constructor() {\n    this.respawn(true);\n  }\n\n  beginRespawn() {\n    this.isRespawning = true;\n  }\n\n  respawn(instantCreate) {\n    \/\/ restart line end point\n    this.xlast = undefined;\n    this.ylast = undefined;\n    this.ulast = undefined;\n    this.vlast = undefined;\n    \/\/ update position\n    this.x = R.random_dec() * 1.88 * BASE_SIZE - BASE_SIZE * 0.44;\n    this.y = R.random_dec() * 1.88 * BASE_SIZE - BASE_SIZE * 0.44;\n    \/\/ update velocity\n    const vel = getVelocityAtPoint([this.x, this.y]);\n    this.u = vel[0];\n    this.v = vel[1];\n    if (instantCreate) {\n      this._radiusMultiplier = 1.0;\n    }\n    this.isRespawning = false;\n  }\n\n  updatePosition() {\n    const vel = getVelocityAtPoint([this.x, this.y]);\n    \/\/ check if particle is moving too fast\n    if (Math.sqrt(vel[0] ** 2 + vel[1] ** 2) > CONFIG.maxParticleSpeed) {\n      this._radiusMultiplier = 0.0;\n      this.respawn(false);\n    } else {\n      \/\/ update previous position and velocity\n      this.xlast = this.x;\n      this.ylast = this.y;\n      this.ulast = this.u;\n      this.vlast = this.v;\n      this.x += vel[0];\n      this.y += vel[1];\n      this.u = vel[0];\n      this.v = vel[1];\n    }\n  }\n\n  draw() {\n    if (this.xlast != undefined) {\n      screen.strokeWeight(\n        M(CONFIG.particleStrokeWeight * this._radiusMultiplier)\n      );\n      screen.curve(\n        Mx(this.xlast - this.ulast),\n        My(this.ylast - this.vlast),\n        Mx(this.xlast),\n        My(this.ylast),\n        Mx(this.x),\n        My(this.y),\n        Mx(this.x + this.u),\n        My(this.y + this.v)\n      );\n    }\n    if (R.random_dec() < CONFIG.particleFrameChanceOfRespawn) {\n      this.beginRespawn();\n    }\n  }\n\n  frameChecks() {\n    if (this.isRespawning) {\n      this._radiusMultiplier -= CONFIG.respawnRadiusDecrement;\n      if (this._radiusMultiplier <= 0) {\n        this.respawn(false);\n      }\n    } else if (this._radiusMultiplier < 1.0) {\n      this._radiusMultiplier = Math.min(\n        1.0,\n        this._radiusMultiplier + CONFIG.respawnRadiusIncrement\n      );\n    }\n  }\n}\n\nconst PARTICLES = [];\nfor (let i = 0; i < NUM_PARTICLES; i++) {\n  PARTICLES.push(new Particle());\n}\n\nfunction setup() {\n  \/\/ create WEBGL canvas\n  createCanvas(WIDTH, HEIGHT, WEBGL);\n  stream = createShader(vertexShader, fragmentShader);\n  \/\/ create off-screen screen buffer\n  screen = createGraphics(WIDTH, HEIGHT);\n  \/\/ define screen defaults\n  screen.background(0);\n  screen.stroke(255);\n  screen.strokeWeight(M(CONFIG.particleStrokeWeight));\n  \/\/ set pixel density to display density for animated piece\n  let density = displayDensity();\n  pixelDensity(density);\n\n  \/\/ set active shader\n  shader(stream);\n\n  \/\/ set shader resolution-related uniforms\n  stream.setUniform(\"M\", [M(1), M(1)]);\n  stream.setUniform(\"Sxy\", [SX, SY]);\n  stream.setUniform(\"D\", density);\n  stream.setUniform(\"WIDTH\", WIDTH);\n  stream.setUniform(\"HEIGHT\", HEIGHT);\n  stream.setUniform(\"OFFSETX\", OFFSETX);\n  stream.setUniform(\"OFFSETY\", OFFSETY);\n  \/\/ set shader vortex-related uniforms\n  stream.setUniform(\"activeElements\", ELEMENTS.length);\n  stream.setUniform(\"useVorticityInPhi\", CONFIG.useVorticityInPhi);\n  stream.setUniform(\"useDivergenceInPsi\", CONFIG.useDivergenceInPsi);\n  frameRate(TARGET_FRAME_RATE);\n\n  stream.setUniform(\"paletteIndex\", PALETTE.index);\n  stream.setUniform(\"limitHueMatlab\", PALETTE.limitHueMatlab || false);\n\n  \/\/ other constants\n  stream.setUniform(\"hueStaticOffset\", CONFIG.hueStaticOffset);\n  stream.setUniform(\"migraine\", CONFIG.migraine);\n  stream.setUniform(\"saturation\", CONFIG.saturation);\n}\n\nfunction draw() {\n  \/\/ update vortex positions and assign in shader\n  updateElementPositions();\n\n  \/\/ define vortex positions in shader, in base coordinates\n  stream.setUniform(\"elementsX\", [...ELEMENTS.map((_el) => _el.x)]);\n  stream.setUniform(\"elementsY\", [...ELEMENTS.map((_el) => _el.y)]);\n  stream.setUniform(\"vortexStrengths\", [\n    ...ELEMENTS.map((_el) => _el.getVortexStrength()),\n  ]);\n  stream.setUniform(\"divergences\", [\n    ...ELEMENTS.map((_el) => _el.getDivergence()),\n  ]);\n\n  \/\/ set multipliers and offsets\n  stream.setUniform(\"psiMult\", CONFIG.psiMult);\n  stream.setUniform(\"phiMult\", CONFIG.phiMult);\n  stream.setUniform(\"phiOffset\", -time_() * CONFIG.phiOffsetMultiplier);\n  stream.setUniform(\"psiOffset\", -time_() * CONFIG.psiOffsetMultiplier);\n\n  \/\/ draw background\n  screen.background(0, CONFIG.backgroundAlpha);\n\n  for (let i = 0; i < NUM_PARTICLES; i++) {\n    PARTICLES[i].updatePosition();\n    PARTICLES[i].frameChecks();\n    PARTICLES[i].draw();\n  }\n  \/\/ Give the shader a surface to draw on;\n  stream.setUniform(\"texture\", screen);\n  rect(-WIDTH \/ 2, -HEIGHT \/ 2, WIDTH, HEIGHT);\n}\n"
}