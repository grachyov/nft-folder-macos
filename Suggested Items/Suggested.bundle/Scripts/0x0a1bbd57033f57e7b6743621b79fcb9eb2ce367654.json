{
  "abId" : "54",
  "address" : "0x0a1bbd57033f57e7b6743621b79fcb9eb2ce3676",
  "kind" : "p5js100",
  "name" : "Square Symphony",
  "screensaverFileName" : "Square.Symphony",
  "value" : "\/\/ CC BY-NC-SA 4.0\nlet R;\nlet objs = [];\nlet minSideLength;\nlet palettes = [\n  [\"#E12A2A\", \"#F0871D\", \"#2E3F93\", \"#E1ECF4\", \"#882585\", \"#de5d5d\", \"#289D4D\"],\n  [\n    \"#fcff4b\",\n    \"#ffad05\",\n    \"#fdfffa\",\n    \"#5995ed\",\n    \"#4ecdc4\",\n    \"#F30100\",\n    \"#70d6ff\",\n    \"#ff70a6\",\n  ],\n  [\"#de183c\", \"#ffd35c\", \"#fd4a8e\", \"#08a9e5\", \"#7209b7\", \"#f0f0f0\", \"#f5822a\"],\n  [\n    \"#e4572e\",\n    \"#17bebb\",\n    \"#ffc914\",\n    \"#76b041\",\n    \"#05569b\",\n    \"#5594d0\",\n    \"#fffef4\",\n    \"#b00000\",\n  ],\n];\nlet colors = [];\nlet bgCol;\nlet spd = 1;\nlet offset = 0;\nlet objCount;\nlet rects = [];\nlet paletteOption;\nlet spdOption;\nlet offsetOption;\nlet gridOption;\nlet backgroundOption;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  rectMode(CENTER);\n  R = new Random();\n  colors = R.random_choice(palettes);\n\n  if (R.random_dec() < 0.3) {\n    spd = R.random_dec() < 0.5 ? 0.5 : 2;\n  }\n  if (R.random_dec() < 0.5) {\n    gridOption = true;\n  } else {\n    gridOption = false;\n  }\n\n  if (R.random_dec() < 0.4) {\n    offsetOption = true;\n  } else {\n    offsetOption = false;\n  }\n\n  if (R.random_dec() < 0.7) {\n    bgCol = \"#121212\";\n    backgroundOption = \"Black\";\n  } else {\n    bgCol = \"#0b0f30\";\n    backgroundOption = \"Navy\";\n  }\n\n  INIT();\n\n  if (palettes[0] == colors) {\n    paletteOption = \"Forest\";\n  } else if (palettes[1] == colors) {\n    paletteOption = \"Seaside\";\n  } else if (palettes[2] == colors) {\n    paletteOption = \"Bubblegum\";\n  } else if (palettes[3] == colors) {\n    paletteOption = \"Firecracker\";\n  }\n\n  if (spd == 1) {\n    spdOption = \"Middle\";\n  } else if (spd < 1) {\n    spdOption = \"Low\";\n  } else {\n    spdOption = \"High\";\n  }\n\n  console.log(\"ColorPalette\", paletteOption);\n  console.log(\"Speed\", spdOption);\n  console.log(\"Offset\", offsetOption);\n  console.log(\"Grid\", gridOption);\n  console.log(\"Background\", backgroundOption);\n}\n\nfunction draw() {\n  background(0);\n  fill(bgCol);\n  noStroke();\n  rect(width \/ 2, height \/ 2, minSideLength);\n  for (let i of objs) {\n    i.run();\n  }\n  drawGrid(gridOption);\n}\n\nfunction drawGrid(bl) {\n  if (bl) {\n    noFill();\n    stroke(255);\n    strokeWeight(minSideLength * 0.001);\n    for (let i of rects) {\n      let x = i[0];\n      let y = i[1];\n      let w = i[2];\n      square(x + w \/ 2, y + w \/ 2, w);\n    }\n  }\n}\n\nfunction divideSquare() {\n  R = new Random();\n  let gridCount = int(R.random_num(20, 33));\n  let gridW = minSideLength \/ gridCount;\n  let gridH = minSideLength \/ gridCount;\n  let emp = gridCount * gridCount;\n  let grids = [];\n\n  for (let j = 0; j < gridCount; j++) {\n    let arr = [];\n    for (let i = 0; i < gridCount; i++) {\n      arr[i] = false;\n    }\n    grids[j] = arr;\n  }\n\n  while (emp > 0) {\n    let w = int(R.random_num(1, 5));\n    let h = w;\n    let x = int(R.random_num(0, gridCount - w + 1));\n    let y = int(R.random_num(0, gridCount - h + 1));\n    let lap = true;\n    for (let j = 0; j < h; j++) {\n      for (let i = 0; i < w; i++) {\n        if (grids[x + i][y + j]) {\n          lap = false;\n          break;\n        }\n      }\n    }\n\n    if (lap) {\n      for (let j = 0; j < h; j++) {\n        for (let i = 0; i < w; i++) {\n          grids[x + i][y + j] = true;\n        }\n      }\n      let xx = x * gridW + (width - minSideLength) \/ 2;\n      let yy = y * gridH + (height - minSideLength) \/ 2;\n      let ww = w * gridW;\n      let hh = h * gridH;\n      rects.push([xx, yy, ww - offset, hh - offset]);\n      emp -= w * h;\n    }\n  }\n  for (let i = 0; i < rects.length; i++) {\n    objCount++;\n    objs.push(new Objct(rects[i][0], rects[i][1], rects[i][2]));\n  }\n}\n\nfunction easeInOutExpo(x) {\n  return x === 0\n    ? 0\n    : x === 1\n    ? 1\n    : x < 0.5\n    ? Math.pow(2, 20 * x - 10) \/ 2\n    : (2 - Math.pow(2, -20 * x + 10)) \/ 2;\n}\n\nfunction INIT() {\n  objs = [];\n  rects = [];\n  minSideLength = min(width, height) * 0.95;\n  objCount = 0;\n  if (offsetOption) {\n    offset = minSideLength * 0.008;\n  }\n  divideSquare();\n}\n\nfunction windowResized() {\n  resizeCanvas(windowWidth, windowHeight);\n  INIT();\n}\n\nclass Objct {\n  constructor(x, y, w) {\n    let rnd = int(R.random_num(0, 8) + 1);\n    if (rnd == 1) this.mtn = new Motion01(x + w \/ 2, y + w \/ 2, w);\n    else if (rnd == 2) this.mtn = new Motion02(x + w \/ 2, y + w \/ 2, w);\n    else if (rnd == 3) this.mtn = new Motion03(x + w \/ 2, y + w \/ 2, w);\n    else if (rnd == 4) this.mtn = new Motion04(x + w \/ 2, y + w \/ 2, w);\n    else if (rnd == 5) this.mtn = new Motion05(x + w \/ 2, y + w \/ 2, w);\n    else if (rnd == 6) this.mtn = new Motion06(x + w \/ 2, y + w \/ 2, w);\n    else if (rnd == 7) this.mtn = new Motion07(x + w \/ 2, y + w \/ 2, w);\n    else if (rnd == 8) this.mtn = new Motion08(x + w \/ 2, y + w \/ 2, w);\n  }\n\n  run() {\n    this.mtn.show();\n    this.mtn.move();\n  }\n}\n\nclass Motion01 {\n  constructor(x, y, w) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.n = int(R.random_num(3, 8));\n    this.sw = w \/ this.n;\n    this.t = -int(R.random_num(0, 10));\n    this.t1 = int(R.random_num(50, 120));\n    this.tStep = R.random_num(0.5, 1) * spd;\n    this.soc = int(R.random_num(0, 2));\n    this.ang = int(R.random_num(0, 4)) * (TAU \/ 4);\n    this.col1 = this.col2 = 0;\n    while (this.col1 == this.col2) {\n      this.col1 = R.random_choice(colors);\n      this.col2 = R.random_choice(colors);\n    }\n  }\n\n  show() {\n    push();\n    translate(this.x, this.y);\n    rotate(this.ang);\n    noFill();\n    strokeWeight(0);\n    strokeCap(SQUARE);\n    rect(0, 0, this.w);\n    drawingContext.setLineDash([this.w \/ this.n, this.w \/ this.n]);\n    strokeWeight(this.sw);\n    stroke(this.col2);\n\n    for (let i = 0; i < this.n; i++) {\n      let yy = map(\n        i,\n        0,\n        this.n - 1,\n        -this.w \/ 2 + this.sw \/ 2,\n        this.w \/ 2 - this.sw \/ 2\n      );\n      let zr = this.soc * ((i % 2) * this.sw);\n      drawingContext.lineDashOffset = zr + this.t * 0.5;\n      line(-this.w \/ 2, yy, this.w \/ 2, yy);\n    }\n    pop();\n  }\n\n  move() {\n    this.t += this.tStep;\n  }\n}\n\nclass Motion02 extends Motion01 {\n  constructor(x, y, w) {\n    super(x, y, w);\n    this.cx = 0;\n    this.cd = w * 0.5;\n  }\n\n  show() {\n    push();\n    translate(this.x, this.y);\n    rotate(this.ang);\n    noFill();\n    stroke(0);\n    strokeWeight(0);\n    rect(0, 0, this.w);\n    drawingContext.clip();\n    noStroke();\n    fill(this.col2);\n    circle(this.cx, 0, this.cd);\n    circle(this.cx - this.w, 0, this.cd);\n    pop();\n  }\n\n  move() {\n    this.t += this.tStep;\n    if (0 < this.t && this.t < this.t1) {\n      let nrm = norm(this.t, 0, this.t1 - 1);\n      this.cx = lerp(0, this.w, easeInOutExpo(nrm));\n    }\n    if (this.t > this.t1) {\n      this.t = 0;\n      this.cx = 0;\n    }\n  }\n}\n\nclass Motion03 extends Motion01 {\n  constructor(x, y, w) {\n    super(x, y, w);\n    this.t2 = this.t1 + 50;\n    this.d = this.w * 0.3;\n    this.sd = this.d;\n    this.sd0 = this.d;\n    this.sd1 = this.d * 4.5;\n    this.sw = this.d;\n  }\n\n  show() {\n    push();\n    translate(this.x, this.y);\n    rotate(this.ang);\n    noFill();\n    stroke(0);\n    strokeWeight(0);\n    rect(0, 0, this.w);\n    drawingContext.clip();\n    noStroke();\n    fill(this.col2);\n    circle(0, 0, this.d);\n    if (this.t < this.t1) {\n      noFill();\n      stroke(this.col2);\n      strokeWeight(this.sw);\n      circle(0, 0, this.sd - this.sw);\n    }\n    pop();\n  }\n\n  move() {\n    if (0 < this.t && this.t < this.t1) {\n      let nrm = norm(this.t, 0, this.t1);\n      this.sd = lerp(this.sd0, this.sd1, easeInOutExpo(nrm));\n      this.sw = lerp(this.d, 0, nrm);\n    }\n    if (this.t > this.t2) {\n      this.t = 0;\n      this.sd = this.sd0;\n    }\n    this.t += this.tStep;\n  }\n}\n\nclass Motion04 extends Motion01 {\n  constructor(x, y, w) {\n    super(x, y, w);\n    this.d = this.w * 0.3;\n    this.rad = this.w * 0.3;\n    this.circles = [];\n    this.cNum = 6;\n    for (let i = 0; i < this.cNum; i++) {\n      this.circles.push({\n        a: 0,\n        d: map(i, 0, this.cNum - 1, this.d, this.d * 0.2),\n      });\n    }\n    this.t1 = int(R.random_num(120, 200));\n    this.cols = [];\n    for (let i = 0; i < colors.length; i++) {\n      this.cols.push(colors[i]);\n    }\n    shuffle(this.cols, true);\n  }\n\n  show() {\n    push();\n    translate(this.x, this.y);\n    rotate(this.ang);\n    noStroke();\n    fill(this.col1);\n    for (let c of this.circles) {\n      circle(this.rad * cos(c.a), this.rad * sin(c.a), c.d);\n    }\n    pop();\n  }\n\n  move() {\n    if (0 < this.t && this.t < this.t1) {\n      let nrm = norm(this.t, 0, this.t1);\n      for (let i = 0; i < this.cNum; i++) {\n        let c = this.circles[i];\n        c.a = lerp(\n          0,\n          TAU,\n          pow(easeInOutExpo(nrm), map(i, 0, this.cNum - 1, 0.7, 5))\n        );\n      }\n    }\n    if (this.t > this.t1) {\n      this.t = 0;\n      for (let i = 0; i < this.cNum; i++) {\n        let c = this.circles[i];\n        c.a = 0;\n      }\n    }\n    this.t += this.tStep;\n  }\n}\n\nclass Motion05 extends Motion01 {\n  constructor(x, y, w) {\n    super(x, y, w);\n    this.cells = [];\n    this.size = this.w \/ this.n;\n    this.tmp = R.random_num(0.02, 0.05);\n    let cols = [];\n    for (let i = 0; i < colors.length; i++) {\n      cols.push(colors[i]);\n    }\n    for (let i = 0; i < this.n; i++) {\n      for (let j = 0; j < this.n; j++) {\n        let x = i * this.size + this.x - this.w \/ 2;\n        let y = j * this.size + this.y - this.w \/ 2;\n        this.cells.push({\n          x: x,\n          y: y,\n          c: R.random_choice(cols),\n          t: int(R.random_num(0, 1000)),\n        });\n      }\n    }\n    this.rnd = int(R.random_num(0, 2));\n  }\n\n  show() {\n    noStroke();\n    for (let i of this.cells) {\n      fill(i.c);\n      if (this.rnd == 0)\n        circle(\n          i.x + this.size \/ 2,\n          i.y + this.size \/ 2,\n          this.size * sin(this.t * this.tmp + i.t) * 0.75\n        );\n      else\n        square(\n          i.x + this.size \/ 2,\n          i.y + this.size \/ 2,\n          this.size * sin(this.t * this.tmp + i.t) * 0.75\n        );\n    }\n  }\n}\n\nclass Motion06 extends Motion01 {\n  constructor(x, y, w) {\n    super(x, y, w);\n    this.wt = int(R.random_num(1, 5));\n    this.cols = [];\n    for (let i = 0; i < colors.length; i++) {\n      this.cols.push(colors[i]);\n    }\n    shuffle(this.cols, true);\n  }\n\n  show() {\n    let amp = this.w \/ this.n;\n    push();\n    translate(this.x, this.y);\n    rotate(this.ang);\n    strokeWeight(0);\n    stroke(0);\n    noFill();\n    rect(0, 0, this.w);\n    drawingContext.clip();\n    noFill();\n    strokeWeight(this.w * 0.02);\n    for (let j = -1; j < this.n + 1; j++) {\n      let yy = map(j, 0, this.n, -this.w \/ 2, this.w \/ 2);\n      stroke(this.cols[floor((j + 1) % this.cols.length)]);\n      beginShape();\n      for (let i = -1; i <= this.w + 1; i++) {\n        let xx = i - this.w \/ 2;\n        let n = norm(i, 0, this.w);\n        vertex(xx, yy + amp * sin(n * this.wt * PI + this.t * 0.1));\n      }\n      endShape();\n    }\n    pop();\n  }\n}\n\nclass Motion07 extends Motion01 {\n  constructor(x, y, w) {\n    super(x, y, w);\n    this.ex = 0;\n    this.ey = 0;\n    this.ew = this.w * 0.2;\n    this.rnd = 1000;\n    this.init();\n  }\n\n  init() {\n    this.t1 = int(R.random_num(40, 100));\n    this.prnd = this.rnd;\n    while (this.rnd == this.prnd) {\n      this.rnd = int(R.random_num(0, 6));\n    }\n    this.ex0 = this.ex;\n    this.ey0 = this.ey;\n    if (this.rnd == 0) {\n      this.ex1 = 0;\n      this.ey1 = 0;\n    } else if (this.rnd == 1) {\n      this.ex1 = this.ew * 0.3;\n      this.ey1 = 0;\n    } else if (this.rnd == 2) {\n      this.ex1 = -this.ew * 0.3;\n      this.ey1 = 0;\n    } else if (this.rnd == 3) {\n      this.ex1 = 0;\n      this.ey1 = this.ew * 0.3;\n    } else if (this.rnd == 4) {\n      this.ex1 = 0;\n      this.ey1 = -this.ew * 0.3;\n    } else if (this.rnd == 5) {\n      this.ex1 = this.ex0;\n      this.ey1 = this.ey0;\n    }\n  }\n\n  show() {\n    push();\n    translate(this.x, this.y);\n    rotate(this.ang);\n    noStroke();\n    fill(this.col1);\n    circle(this.w * 0.28, 0, this.w * 0.35);\n    circle(-this.w * 0.28, 0, this.w * 0.35);\n    fill(this.col2);\n    circle(this.w * 0.28 + this.ex, this.ey, this.ew);\n    circle(-this.w * 0.28 + this.ex, this.ey, this.ew);\n    if (this.rnd == 5) {\n      fill(bgCol);\n      rect(0, -this.w * 0.3 + this.tn, this.w, -0 + this.tn * 2);\n    }\n    pop();\n  }\n\n  move() {\n    this.t += this.tStep;\n    if (0 < this.t && this.t < this.t1) {\n      let nrm = norm(this.t, 0, this.t1 - 1);\n      this.ex = lerp(this.ex0, this.ex1, easeInOutExpo(nrm));\n      this.ey = lerp(this.ey0, this.ey1, easeInOutExpo(nrm));\n      if (this.rnd == 5)\n        this.tn = lerp(0, this.w * 0.3, sin(easeInOutExpo(nrm) * PI));\n    }\n    if (this.t > this.t1) {\n      this.t = 0;\n      this.init();\n    }\n  }\n}\n\nclass Motion08 extends Motion01 {\n  constructor(x, y, w) {\n    super(x, y, w);\n    this.rad = this.w * 0.35;\n    this.pom = R.random_dec() < 0.5 ? -1 : 1;\n  }\n\n  show() {\n    push();\n    translate(this.x, this.y);\n    rotate(this.ang);\n    fill(this.col1);\n    for (let i = 0; i < 12; i++) {\n      let a = map(i, 0, 12, 0, TAU);\n      circle(this.rad * cos(a), this.rad * sin(a), this.w * 0.05);\n    }\n    let a = this.t * 0.02 * this.pom;\n    stroke(this.col2);\n    strokeWeight(this.w * 0.04);\n    line(0, 0, this.rad * cos(a), this.rad * sin(a));\n    line(\n      0,\n      0,\n      this.w * 0.2 * cos(a \/ TAU \/ 2),\n      this.w * 0.2 * sin(a \/ TAU \/ 2)\n    );\n    pop();\n  }\n}\n\nclass Random {\n  constructor() {\n    this.useA = false;\n    let sfc32 = function (uint128Hex) {\n      let a = parseInt(uint128Hex.substr(0, 8), 16);\n      let b = parseInt(uint128Hex.substr(8, 8), 16);\n      let c = parseInt(uint128Hex.substr(16, 8), 16);\n      let d = parseInt(uint128Hex.substr(24, 8), 16);\n      return function () {\n        a |= 0;\n        b |= 0;\n        c |= 0;\n        d |= 0;\n        let t = (((a + b) | 0) + d) | 0;\n        d = (d + 1) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        c = (c + t) | 0;\n        return (t >>> 0) \/ 4294967296;\n      };\n    };\n    \/\/ seed prngA with first half of tokenData.hash\n    this.prngA = new sfc32(tokenData.hash.substr(2, 32));\n    \/\/ seed prngB with second half of tokenData.hash\n    this.prngB = new sfc32(tokenData.hash.substr(34, 32));\n    for (let i = 0; i < 1e6; i += 2) {\n      this.prngA();\n      this.prngB();\n    }\n  }\n  \/\/ random number between 0 (inclusive) and 1 (exclusive)\n  random_dec() {\n    this.useA = !this.useA;\n    return this.useA ? this.prngA() : this.prngB();\n  }\n  \/\/ random number between a (inclusive) and b (exclusive)\n  random_num(a, b) {\n    return a + (b - a) * this.random_dec();\n  }\n  \/\/ random integer between a (inclusive) and b (inclusive)\n  \/\/ requires a < b for proper probability distribution\n  random_int(a, b) {\n    return Math.floor(this.random_num(a, b + 1));\n  }\n  \/\/ random boolean with p as percent liklihood of true\n  random_bool(p) {\n    return this.random_dec() < p;\n  }\n  \/\/ random value in an array of items\n  random_choice(list) {\n    return list[this.random_int(0, list.length - 1)];\n  }\n}"
}