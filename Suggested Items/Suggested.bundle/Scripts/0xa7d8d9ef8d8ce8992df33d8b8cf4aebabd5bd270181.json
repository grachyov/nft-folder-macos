{
  "abId" : "181",
  "address" : "0xa7d8d9ef8d8ce8992df33d8b8cf4aebabd5bd270",
  "kind" : "p5js100",
  "name" : "FOCUS",
  "screensaverFileName" : "FOCUS",
  "value" : "\/\/ Find a non-minified and better commented version of this script online at the artist's website. Copyright Matthew Costanza 2021\r\nlet hV, hb, binL, tkB, shape, shapeI, sRef, sIRef, pattB, pBRef, pattI, pIRef, isS, midPs, recP, recS, pal, ar, cW, cH, minD, s, col, arm, w, b, a, v, g, r, p;\r\nlet binP = 0;\r\nlet gR = 0.618;\r\nlet def = 0.382;\r\nlet allPattP = [];\r\nlet allSP = [];\r\nlet showShape = true;\r\ncalculateFeatures(tokenData);\r\nsetDim();\r\n\r\nfunction calculateFeatures(tD) {\r\n  tkB = tD.tokenId % 2;\r\n  hV = cHVal(tD.hash);\r\n  hb = cHBin(hV);\r\n  binL = hb.length;\r\n  w = \"#ffffff\";\r\n  b = \"#000000\";\r\n  a = \"#275bb2\";\r\n  v = \"#43AA8B\";\r\n  g = \"#fcd612\";\r\n  r = \"#b10b0b\";\r\n  p = \"#f368cb\";\r\n  shape = gV(1, 9);\r\n  if (shape < 4) {\r\n    ar = 1;\r\n  } else if (shape < 7) {\r\n    ar = 2;\r\n  } else {\r\n    ar = 3;\r\n  }\r\n  shapeI = gV(1, 5);\r\n  pattB = gV(1, 100);\r\n  if (pattB > 62) { \r\n    pattB = 1;\r\n  } else if (pattB > 42) { \r\n    pattB = 2;\r\n  } else if (pattB > 22) { \r\n    pattB = 3;\r\n  } else if (pattB > 2) { \r\n    pattB = 4;\r\n  } else { \r\n    pattB = 5;\r\n  }\r\n  pattI = gV(1, 11);\r\n  if (pattI < 4 && pattB == 2) {\r\n    pattB = 1;\r\n  } \r\n  midPs = gV(1,6);\r\n  midPs = 2 ** midPs - 1;\r\n  if (midPs == 1 && (pattB == 2 || pattI == 7 || pattI == 8)) {\r\n    midPs = 3;\r\n  }\r\n  if (midPs < 5 && pattI == 9) {\r\n    midPs = 5;\r\n  }\r\n  recP = gV(0, 5);\r\n  rP = 2 ** recP;\r\n  recS = gV(0, 3);\r\n  if ((shape == 6 || shape == 9) && shapeI == 1) {\r\n    rS = 1;\r\n  } else if (shapeI == 4) {\r\n    rS = 2;\r\n  } else if ((shape == 6 || shape == 9) && shapeI == 3) {\r\n    rS = Math.min((3 ** recS), 5);\r\n  } else {\r\n    rS = 3 ** recS;\r\n  }\r\n  pal = gV(0, 19); \r\n  let cols = [\r\n    [w, b, v, w], \r\n    [w, b, a, w], \r\n    [w, b, r, w], \r\n    [w, b, p, w], \r\n    [w, b, g, w], \r\n    [w, b, r, g],\r\n    [w, b, a, g],\r\n    [w, b, v, g],\r\n    [b, w, v, g],\r\n    [b, w, a, g],\r\n    [b, g, w, g], \r\n    [b, w, b, w],\r\n    [a, r, w, g],\r\n    [a, g, w, g], \r\n    [a, w, v, w],\r\n    [a, w, b, w],\r\n    [r, w, b, g],\r\n    [r, w, a, w],\r\n    [v, w, a, w],\r\n    [g, b, w, b]\r\n  ];\r\n  col = cols[pal];\r\n  if (shapeI == 5 && col[1] == col[3]) {\r\n    shapeI = 2;\r\n  }\r\n  if (rS == 1 && (shapeI == 3 || shapeI == 5)) {\r\n    shapeI = 2;\r\n  }\r\n  if (shapeI == 2 && rS > 1) {\r\n    rS = 1;\r\n  }\r\n  if (pattB == 5 && pattI == 11) {\r\n    if (shapeI == 2 || shapeI == 1) {\r\n      isS = \"Portal\";\r\n    } else {\r\n      isS = \"Truth\";\r\n    }\r\n  } else {\r\n    isS = \"Yes\";\r\n  }\r\n\r\n  function cHVal(TH) {\r\n    let h = [];\r\n    for (let i = 0; i < (TH.length - 2) \/ 2; i++) {\r\n      h.push(parseInt(TH.slice(2 + i * 2, 4 + i * 2), 16));\r\n    }\r\n    return h;\r\n  }\r\n  \r\n  function cHBin(H) {\r\n    let b = '';\r\n    for (let i = 0; i < H.length - 1; i++) {\r\n      let t = H[i].toString(2);\r\n      b = b + t;\r\n    }\r\n    return b;\r\n  }\r\n  \r\n  function gV(min, max) {\r\n    max = max + 0.999; \r\n    let x = Math.floor((hV[0] * (max - min)) \/ 255 + min);\r\n    hV.shift();\r\n    return x;\r\n  }  \r\n}\r\n\r\nfunction setDim() {\r\n  binP = 0;\r\n  let winW = window.innerWidth;\r\n  let winH = window.innerHeight;\r\n  minD = Math.min(winW, winH);\r\n  if (ar == 1) {\r\n    arm = 1;\r\n    cW = minD;\r\n    cH = minD;\r\n  } else if (ar == 2) {\r\n    arm = gR;\r\n    if (winW \/ winH >= gR) {\r\n      cH = winH;\r\n      cW = Math.floor(gR * cH);\r\n    } else {\r\n      cW = winW;\r\n      cH = Math.floor(cW \/ gR);\r\n    }\r\n  } else if (ar == 3) {\r\n    arm = 1 \/ gR;\r\n    if (winH \/ winW >= gR) {\r\n      cW = winW;\r\n      cH = Math.floor(gR * cW);\r\n    } else {\r\n      cH = winH;\r\n      cW = Math.floor(cH \/ gR);\r\n    }\r\n  }\r\n  u = (Math.max(cW, cH)) \/ 300;\r\n}\r\nfunction windowResized() {\r\n  allPattP = [];\r\n  allSP = [];\r\n  setDim()\r\n  resizeCanvas(cW, cH);\r\n}\r\n\r\nfunction getBin() {\r\n  let b = hb[binP];\r\n  binP = (binP + 1 != binL) ? binP + 1 : 0;\r\n  return b;\r\n}\r\n\r\nfunction keyPressed() {\r\n  if (key === 's') {\r\n    saveCanvas('FOCUS-' + `${tokenData.tokenId}` + '_hash-' + `${tokenData.hash}` + '_RecursionFactor-' + `${rP}` + '_midpoints-' + `${midPs}` + '_shape-' + `${showShape}`, 'png')\r\n  } else if (key === 'h') {\r\n    if (showShape == true) {\r\n      showShape = false;\r\n    } else {\r\n      showShape = true;\r\n    }\r\n    windowResized()\r\n  } else if (keyCode === RIGHT_ARROW) {\r\n    midPs +=2;\r\n    windowResized();\r\n  } else if (keyCode === LEFT_ARROW) {\r\n    midPs > 1 ? midPs -= 2 : midPs = 1;\r\n    windowResized();\r\n  } else if (keyCode === UP_ARROW) {\r\n    rP += 1;\r\n    windowResized();\r\n  } else if (keyCode === DOWN_ARROW) {  \r\n    rP > 1 ? rP -= 1 : rP = 1;\r\n    windowResized();\r\n  } \r\n}\r\n\r\nfunction setup() {\r\n  createCanvas(cW, cH);\r\n  angleMode(DEGREES);\r\n}function draw() {\n  background(col[0]);\n  strokeWeight(u * 0.8);\n  stroke(col[1]);\n  let m = 2 * u;\n  let tEC = cH * def * gR;\n  let wEC = cW * def * gR;\n  let hH = cH \/ 2;\n  let hW = cW \/ 2;\n  pattSides = [\n    [[m, m], [cW - m, m]],\n    [[cW - m, m], [cW - m, cH - m]],\n    [[cW - m, cH - m], [m, cH - m]],\n    [[m, cH - m], [m, m]]\n  ];\n  let recFP = [\n    [[m, m], [cW - m, m]],\n    [[cW - m, m], [cW - m, cH - m]],\n    [[cW - m, cH - m], [m, cH - m]],\n    [[m, cH - m], [m, m]]\n  ];\n  let cenP = [\n    [[hW, hH], [hW, hH]],\n    [[hW, hH], [hW, hH]],\n    [[hW, hH], [hW, hH]],\n    [[hW, hH], [hW, hH]],\n  ];\n  allPattP.push(buildQuad(pattSides));\n  if (rP == 1) {\n    allPattP.push(buildQuad(cenP));\n  }\n  for (let i = 1; i < rP; i++) {\n    rectRecurser(recFP, cW \/ 1.3, cH \/ 1.3, rP);\n    allPattP.push(buildQuad(recFP));\n  }\n\n  let shapeSides = [];\n  let wCalc = (cW - cW * def) \/ 2;\n  let hCalc = (cH - cH * def) \/ 2;\n  if (shape == 1 || shape == 4 || shape == 7) {\n    shapeSides = [\n      [[wCalc, hCalc], [cW - wCalc, hCalc]],\n      [[cW - wCalc, hCalc], [cW - wCalc, cH - hCalc]],\n      [[cW - wCalc, cH - hCalc], [wCalc, cH - hCalc]],\n      [[wCalc, cH - hCalc], [wCalc, hCalc]]\n    ];\n  }\n  if (shape == 2 || shape == 5 || shape == 8) {\n    shapeSides = [\n      [[wCalc, hH], [hW, hCalc]],\n      [[hW, hCalc], [cW - wCalc, hH]],\n      [[cW - wCalc, hH], [hW, cH - hCalc]],\n      [[hW, cH - hCalc], [wCalc, hH]]\n    ];\n  }\n  if (shape != 3 && shape != 6 && shape != 9) {\n    for (let i = 1; i <= rS; i++) {\n      allSP.push(buildQuad(shapeSides));\n      if (shape == 1 || shape == 4 || shape == 7) {\n        rectRecurser(shapeSides, cW \/ 1.66, cH \/ 1.66, rS);\n      }\n      if (shape == 2 || shape == 5 || shape == 8) {\n        diamRecurser(shapeSides, cW \/ 1.66, rS);\n      }\n    }\n  }\n  if (shape == 3) { \n    let cP = (midPs + 1) * 4;\n    let radi = cW * def \/2;\n    for (let i = 1; i <= rS; i++) {\n      let points = [];\n      points.push(circumP(cP,radi));\n      allSP.push(points);\n      radi = radi - radi \/ 4;\n    }\n  }\n  function circumP(cP, radi) {\n    let ps = [];\n    for (let i = 0; i < cP; i++) {\n      let x = (radi * Math.cos((2 * Math.PI * i) \/ cP)) + hW;\n      let y = (radi * Math.sin((2 * Math.PI * i) \/ cP)) + hH;\n      ps.push([x, y]);\n    }\n    return ps;\n  }\n  if (shape == 6 || shape == 9) {\n    let cP = midPs + 1;\n    let side1 = [];\n    let side2 = [];\n    for (let i = 0; i <= cP; i++) {\n      let t = i \/ cP;\n      if (shape == 6) {\n        side1.push(getCurvePoints(cW + wEC, 0, hW, hCalc, hW, cH - hCalc, cW + wEC, cH, t));\n        side2.push(getCurvePoints(-wEC, cH, hW, cH - hCalc, hW, hCalc, -wEC, 0, t));\n      } else {\n        side1.push(getCurvePoints(0, cH + tEC, wCalc, hH, cW - wCalc, hH, cW, cH + tEC, t));\n        side2.push(getCurvePoints(cW, - tEC, cW - wCalc, hH, wCalc, hH, 0, - tEC, t));\n      }\n      function getCurvePoints(c1x, c1y, x1, y1, x2, y2, c2x, c2y, t) {\n        x = curvePoint(c1x, x1, x2, c2x, t);\n        y = curvePoint(c1y, y1, y2, c2y, t);\n        let p = [x, y];\n        return p;\n      }\n    }\n    allSP.push([side1, side2]);\n    for (let i = 1; i < rS; i++) {\n      let lastSet = allSP.length -1;\n      let newSet = [];\n      for (let crv = 0; crv <2; crv ++){\n        let newPs = [];\n        for (let v = 0; v < allSP[lastSet][crv].length; v++) {\n          let oldP = allSP[lastSet][crv][v];\n          let newX, newY;\n          if (shape == 6) {\n            newY = ((oldP[1] - hH)) * .88 + hH;\n            newX = oldP[0];\n          } else {\n            newX = ((oldP[0] - hW)) * .88 + hW;\n            newY = oldP[1];\n          }\n          newPs.push([newX,newY]);\n        }\n        newSet.push(newPs);\n      }\n    allSP.push(newSet);\n    }\n  }\n\n  function rectRecurser(ss, xLim, yLim, r) {\n    let xD = (xLim - ss[0][0][0]) \/ r;\n    let yD = (yLim - ss[0][0][1]) \/ r;\n    ss[0][0][0] += xD;\n    ss[0][0][1] += yD;\n    ss[0][1][0] -= xD;\n    ss[0][1][1] += yD;\n    ss[1][0][0] -= xD;\n    ss[1][0][1] += yD;\n    ss[1][1][0] -= xD;\n    ss[1][1][1] -= yD;\n    ss[2][0][0] -= xD;\n    ss[2][0][1] -= yD;\n    ss[2][1][0] += xD;\n    ss[2][1][1] -= yD;\n    ss[3][0][0] += xD;\n    ss[3][0][1] -= yD;\n    ss[3][1][0] += xD;\n    ss[3][1][1] += yD;\n  }\n\n  function diamRecurser(ss, xLim, r) {\n    let xD = (xLim - ss[0][0][0])\/r;\n    ss[0][0][0] += xD;\n    ss[0][1][1] += xD;\n    ss[1][0][1] += xD;\n    ss[1][1][0] -= xD;\n    ss[2][0][0] -= xD;\n    ss[2][1][1] -= xD;\n    ss[3][0][1] -= xD;\n    ss[3][1][0] += xD;\n  }\n\n  function buildQuad(qSides) {\n    rectMode(CENTER);\n    let allP = [];\n    let sideP = [];\n    for (let side = 0; side < 4; side++) {\n      sideP = lineBreaker(qSides[side][0], qSides[side][1]);\n      allP.push(sideP);\n    }\n    return allP;\n    function lineBreaker(p1, p2) {\n      let lineP = [[...p1]];\n      for (let i = 1; i < midPs + 2; i++) {\n        lineP.push(getPoint(p1, p2, i \/ (midPs + 1)));\n      }\n      lineP.push([...p2]);\n      return lineP;\n      function getPoint(p1, p2, t) {\n        let newX = t * (p2[0] - p1[0]) + p1[0];\n        let newY = t * (p2[1] - p1[1]) + p1[1];\n        let point = [newX, newY];\n        return point;\n      }\n    }\n  }  drawStyle(allPattP, pattI, true);\n\n  let cMem = col[2];\n  if (showShape == true) {\n    if (shapeI == 1) {\n      noFill();\n    } else { \n      fill(col[3]);\n    }\n    if (shape == 1) {\n      rect(hW, hH, cW * def, cH * def);\n    } \n    if (shape == 4) {\n      rect(hW, hH, tEC, cH * def);\n    } \n    if (shape == 7) {\n      rect(hW, hH, cW * def, wEC);\n    } \n    if (shape == 2 || shape == 5 || shape == 8) {\n      quad(hW, hCalc, cW - wCalc, hH, hW, cH - hCalc, wCalc, hH);\n    } \n    if (shape == 3) {\n      circle(hW, hH, cW * def);\n    } \n    if (shape == 6) {\n      if (shapeI != 1) {\n        strokeWeight(u * 2);\n        stroke(col[3]);\n        line(hW, hCalc + 2 * u, hW, cH - hCalc - 2 * u);\n        strokeWeight(u * 0.8);\n        stroke(col[1]);\n      }\n      dTE(0);\n    } \n    if (shape == 9) {\n      if (shapeI != 1) {\n        strokeWeight(u * 2);\n        stroke(col[3]);\n        line(wCalc + 2 * u, hH, cW - wCalc - 2 * u, hH);\n        strokeWeight(u * 0.8);\n        stroke(col[1]);\n      }\n      dWE(0);\n    }\n    if (shapeI == 5) {\n      drawStyle(allSP, 4, false);\n    }\n    if (rS == 2) {\n      if (col[0] != col[3]) {\n      col[2] = col[0];\n      }\n    }\n    if (shapeI == 1 || shapeI == 3 || rS == 2) {\n      if (shapeI !=1) {\n        noStroke();\n      } else {\n        noFill();\n      }\n      if (shape != 3 && shape != 6 && shape != 9) {\n        for (let i = 1; i < allSP.length; i++) {\n          if (shapeI != 1) {\n            fill(col[3 - (i % 2)]);\n          }\n          quad(allSP[i][0][0][0], allSP[i][0][0][1], allSP[i][1][0][0], allSP[i][1][0][1], allSP[i][2][0][0], allSP[i][2][0][1], allSP[i][3][0][0], allSP[i][3][0][1]);\n        }\n      } else if (shape == 3) {\n        let rr = cW * def;\n        for (let i = 1; i < rS; i++) {\n          rr = rr - rr \/ 4;\n          if (shapeI != 1) {\n            fill(col[3 - (i % 2)]);\n          }\n          circle(hW, hH, rr);\n        }\n      } else {\n        let fdist = Math.max(Math.abs(allSP[0][0][0][0] - allSP[0][1][0][0]), Math.abs(allSP[0][0][0][1] - allSP[0][1][0][1])) \/ 4;\n        rr = 0;\n        let fMem;\n        for (let i = 1; i < rS; i++) {\n          rr = rr - fdist;\n          fMem = col[3 - (i % 2)];\n          fill(fMem);\n          strokeWeight(u * 2);\n          stroke(fMem);  \n          if (shape == 6) {\n            line(hW, hCalc + 2 * u, hW, cH - hCalc - 2 * u);\n            strokeWeight(u * 0.8);\n            stroke(col[3]);\n            dTE(rr);\n          }\n          if (shape == 9) {           \n            line(wCalc + 2 * u, hH, cW - wCalc - 2 * u, hH);\n            strokeWeight(u * 0.8);\n            stroke(col[3]);\n            dWE(rr);\n          }\n        }\n        stroke(col[1]);\n        noFill();\n        if (shape == 9) {\n          dWE(0);\n        }\n        if (shape == 6) {\n          dTE(0);\n        }    \n      }\n    }\n    function dTE(v) {\n      curve(cW + wEC + v, 0, hW, hCalc, hW, cH - hCalc, cW + wEC + v, cH);\n      curve(-wEC - v, 0, hW, hCalc, hW, cH - hCalc, -wEC - v, cH);\n    }\n    function dWE(v) {\n      curve(0, cH + tEC + v, wCalc, hH, cW - wCalc, hH, cW, cH + tEC + v);\n      curve(0, - tEC - v, wCalc, hH, cW - wCalc, hH, cW, - tEC - v);\n    }\n  } \n\n  function drawStyle(allP, m, patt) {\n    strokeJoin(BEVEL);\n    fill(col[2]);\n    let dir;\n    for (let i = 0; i < allP.length; i++) { \n      let ls;\n      if (ar == 2) {\n        ls = 1;\n      } else {\n        ls = 0;\n      } \n      let size = Math.max((Math.abs(allP[i][ls][0][0] - allP[i][ls][allP[i][ls].length - 1][0])), Math.abs((allP[i][ls][0][1] - allP[i][ls][allP[i][ls].length - 1][1]))) \/ 110; \n      if (patt == true && m < 4 ) {\n        fill(col[0]);\n        rect(hW, hH, allP[i][0][allP[i][0].length - 1][0] - allP[i][0][0][0], allP[i][1][allP[i][1].length - 1][1] - allP[i][1][0][1]);\n        dir = getBin();\n        fill(col[2]);\n      }\n      for (let j = 0; j < allP[i].length; j++) {\n        if (patt == true && pattB == 1) {\n          line(allP[i][j][0][0], allP[i][j][0][1], allP[i][j][allP[i][j].length -1][0], allP[i][j][allP[i][j].length - 1][1]);\n        }\n        for (let k = 0; k < allP[i][j].length; k++) {\n          let aPx = allP[i][j][k][0];\n          let aPy = allP[i][j][k][1];  \n          if (m == 1 && k + 1 < allP[i][j].length && (j < 2)) { \n              line(aPx, aPy, allP[i][j + 2][allP[i][j].length - k - 2][0], allP[i][j + 2][allP[i][j].length - k - 2][1]);\n          }\n          if (m == 2 && j == dir && k + 1 < allP[i][j].length) {\n            if (dir == 0) {\n              line(aPx, aPy, allP[i][j + 2][allP[i][j].length - k - 2][0], allP[i][j + 2][allP[i][j].length - k - 2][1]);\n            } else {\n              line(aPx, aPy, allP[i][j + 2][allP[i][j].length - k - 2][0], allP[i][j + 2][allP[i][j].length - k - 2][1]);\n            }\n          } \n          if (m == 3) {\n            let len, leg2;\n            let p1 = [allP[i][j][0][0], allP[i][j][0][1]];\n            let p2 = [allP[i][j][allP[i][j].length - 1][0], allP[i][j][allP[i][j].length - 1][1]];\n            let md = j % 2;\n            let leg = Math.min(Math.abs(allP[i][j][k][md] - p1[md]), Math.abs(p2[md] - allP[i][j][k][md]));\n            if (j == 0) {\n              leg2 = leg \/ arm;\n              len = Math.min(aPy + leg2, hH);\n              line(aPx, aPy, aPx, len);\n            } else if (j == 1) {\n              leg2 = leg * arm;\n              len = Math.max(aPx - leg2, hW);\n              line(aPx, aPy, len, aPy);\n            } else if (j == 2) {\n              leg2 = leg \/ arm;\n              len = Math.max(aPy - leg2, hH);\n              line(aPx, aPy, aPx, len);\n            } else if (j == 3) {\n              leg2 = leg * arm;\n              len = Math.min(aPx + leg2, hW);\n              line(aPx, aPy, len, aPy);\n            }\n          }\n          if (m == 4 && i + 1 < allP.length) {\n            line(aPx, aPy, allP[i+1][j][k][0], allP[i+1][j][k][1]);\n          }\n          if (m == 5 && i + 1 < allP.length && k + 2 < allP[i][j].length) {\n            line(aPx, aPy, allP[i+1][j][k+1][0], allP[i+1][j][k+1][1]);\n          }\n          if (m == 6 && i + 1 < allP.length && getBin() == 1) {\n            line(aPx, aPy, allP[i + 1][j][k][0], allP[i + 1][j][k][1]);\n          } \n          if (m == 7 && i + 1 < allP.length && k + 2 < allP[i][j].length && (k % 2 == 0)) {\n            quad(aPx, aPy, allP[i][j][k+1][0], allP[i][j][k+1][1], allP[i+1][j][k+1][0], allP[i+1][j][k+1][1], allP[i+1][j][k][0], allP[i+1][j][k][1]);\n          } \n          if (m == 8 && i + 1 < allP.length && k + 2 < allP[i][j].length && (k % 2 == i % 2)) {\n            quad(aPx, aPy, allP[i][j][k+1][0], allP[i][j][k+1][1], allP[i+1][j][k+1][0], allP[i+1][j][k+1][1], allP[i+1][j][k][0], allP[i+1][j][k][1]);\n          } \n          if (m == 9 && i + 1 < allP.length && k + 2 < allP[i][j].length && (k % 2 == i % 2) && getBin() == 1) {\n            quad(aPx, aPy, allP[i][j][k+1][0], allP[i][j][k+1][1], allP[i+1][j][k+1][0], allP[i+1][j][k+1][1], allP[i+1][j][k][0], allP[i+1][j][k][1]);\n          }\n          if (m == 10 && i + 1 < allP.length && k + 2 < allP[i][j].length) {\n            if (tkB == 0) {\n              quad(aPx, aPy, allP[i][j][k+1][0], allP[i][j][k+1][1], allP[i+1][j][k][0], allP[i+1][j][k][1], aPx, aPy);\n            } else {\n              quad(aPx, aPy, allP[i][j][k+1][0], allP[i][j][k+1][1], allP[i+1][j][k+1][0], allP[i+1][j][k+1][1], aPx, aPy);\n            }\n          }\n          if (patt == true) {\n            noFill();\n            if (pattB == 3) {\n              let fS = size;\n              if (u * 0.8 > size) {\n                noStroke();\n                fill(col[1]);\n                fS = size + 0.8 * u;\n              }\n              circle(aPx, aPy, fS);\n            }\n            if (pattB == 4) {\n              rect(aPx, aPy, size);\n            }\n            if (pattB == 2 && k % 2 == 1 && k + 1 < allP[i][j].length) {\n              line(aPx, aPy, allP[i][j][k + 1][0], allP[i][j][k + 1][1]);\n            }\n            stroke(col[1]);\n            fill(col[2]);\n          }\n        }\n      }\n    }\n  }\n\n  if (isS == \"Portal\") {\n    stroke(col[1]);\n    let bW, bSY;\n    if (shape == 1 || shape == 4 || shape == 7) {\n      bW = cW * def + 2*u;\n      bSY = allSP[0][2][0][1]; \n    } else if (shape == 3) {\n      bW = 40 * u; \n      bSY = hW + (cW * def \/2);\n    } else if (shape == 9) {\n      bW = 15 * u; \n      bSY = allSP[0][1][(allSP[0][1].length - 1)\/2][1];\n    } else if (shape == 6) {\n      bW = 2*u; \n      bSY = allSP[0][1][0][1];\n    } else {\n      bW = Math.abs(allSP[0][0][0][0] - allSP[0][2][0][0]) \/ 10;\n      bSY = allSP[0][3][0][1];\n    }\n    let space = 4 * u;\n    let bX1 = (hW) - (bW\/2);\n    let bX2 = (hW) + (bW\/2);\n    let yG = (cH - bSY);\n    xD = bX1\/(yG\/space);\n    line(bX1, bSY + space, bX2, bSY + space);\n    for (let c = 2; c < yG \/ space; c++) {\n      bX1 = bX1 - xD;\n      bX2 = bX2 + xD;\n      let xD1 = getBin() * space\/2  * ((getBin() * 2) - 1);\n      let xD2 = getBin() * space\/2  * ((getBin() * 2) - 1);\n      line(bX1 - xD1, bSY + c * space, bX2 + xD2, bSY + c * space);\n    } \n  }\n  col[2] = cMem;\n  noLoop();\n}"
}