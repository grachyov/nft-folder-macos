{
  "contractAddress" : "0x99a9b7c1116f9ceeb1652de04d5969cce509b069",
  "kind" : "p5js100",
  "projectId" : "435",
  "script" : "class Random {\n  constructor() {\n    this.useA = false;\n    let sfc32 = function (uint128Hex) {\n      let a = parseInt(uint128Hex.substr(0, 8), 16);\n      let b = parseInt(uint128Hex.substr(8, 8), 16);\n      let c = parseInt(uint128Hex.substr(16, 8), 16);\n      let d = parseInt(uint128Hex.substr(24, 8), 16);\n      return function () {\n        a |= 0;\n        b |= 0;\n        c |= 0;\n        d |= 0;\n        let t = (((a + b) | 0) + d) | 0;\n        d = (d + 1) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        c = (c + t) | 0;\n        return (t >>> 0) \/ 4294967296;\n      };\n    };\n    \/\/ seed prngA with first half of tokenData.hash\n    this.prngA = new sfc32(tokenData.hash.substr(2, 32));\n    \/\/ seed prngB with second half of tokenData.hash\n    this.prngB = new sfc32(tokenData.hash.substr(34, 32));\n    for (let i = 0; i < 1e6; i += 2) {\n      this.prngA();\n      this.prngB();\n    }\n  }\n  \/\/ random number between 0 (inclusive) and 1 (exclusive)\n  random_dec() {\n    this.useA = !this.useA;\n    return this.useA ? this.prngA() : this.prngB();\n  }\n  \/\/ random number between a (inclusive) and b (exclusive)\n  random_num(a, b) {\n    return a + (b - a) * this.random_dec();\n  }\n  \/\/ random integer between a (inclusive) and b (inclusive)\n  \/\/ requires a < b for proper probability distribution\n  random_int(a, b) {\n    return Math.floor(this.random_num(a, b + 1));\n  }\n  \/\/ random boolean with p as percent liklihood of true\n  random_bool(p) {\n    return this.random_dec() < p;\n  }\n}\nlet R = new Random();\n\n\/\/ define and preload stream shader\nlet stream;\nlet vertexShader = `\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 pos;\n\nvoid main() {\n  \/\/ copy the texcoords\n  pos = aTexCoord;\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  positionVec4.xy = positionVec4.xy * 2.0 - 1.0;\n  gl_Position = positionVec4;\n}\n`;\nlet fragmentShader = `\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec2 pos;\nuniform sampler2D texture;\n\n\/\/ multiplier to scale to screen size\nuniform vec2 M;\n\/\/ ratios of screen dims to base dims\nuniform vec2 Sxy;\n\/\/ pixel density of display\nuniform float D;\n\/\/ screen values to calculate offsets later\nuniform float OFFSETX;\nuniform float OFFSETY;\n\n\/\/ stream function\nuniform float psiMult;\nuniform float psiOffset;\nuniform bool useDivergenceInPsi;\n\/\/ velocity potential\nuniform float phiMult;\nuniform float phiOffset;\nuniform bool useVorticityInPhi;\n\nconst int maxElements = 14;\nuniform int activeElements;\nuniform float elementsX[14];\nuniform float elementsY[14];\nuniform float vortexStrengths[14];\nuniform float divergences[14];\n\nuniform int paletteIndex;\nuniform bool limitHueMatlab;\n\nuniform float hueStaticOffset;\nuniform bool migraine;\nuniform float saturation;\n\n\/\/ gets stream and velocity potential function values\n\/\/ @dev all calculations in base coordinates\nvec2 getPsiPhi(vec2 bc) {\n  float psi = 0.0;\n  float phi = 0.0;\n  \/\/ flow elements\n  for (int i = 0; i < maxElements; i++) {\n    if (i >= activeElements) {\n      break;\n    }\n    float r = distance(bc, vec2(elementsX[i], elementsY[i]));\n    float theta = atan((bc.y - (elementsY[i])), (bc.x - (elementsX[i])));\n    \/\/ vorticity\n    psi = psi + (1.0 * vortexStrengths[i]) * log(r);\n    if (useVorticityInPhi) {\n      phi = phi + vortexStrengths[i] * theta;\n    } else {\n      if (vortexStrengths[i] < 0.0) {\n        phi = phi + theta;\n      } else {\n        phi = phi - theta;\n      }\n    }\n    \/\/ divergence (source\/sink)\n    if (useDivergenceInPsi) {\n      psi = psi + divergences[i] * theta;\n    } else {\n      \/\/ already added theta in vorticity section\n    }\n    phi = phi - divergences[i] * log(r);\n  }\n  \/\/ uniform flow not utilized in this project\n  return vec2(psi, phi);\n}\n\/\/ gets velocity magnitude\n\/\/ @dev all calculations in base coordinates\nfloat getVelocityMagnitude(vec2 bc) {\n  float u = 0.0;\n  float v = 0.0;\n  \/\/ flow elements\n  for (int i = 0; i < maxElements; i++) {\n    if (i >= activeElements) {\n      break;\n    }\n    float r = distance(bc, vec2(elementsX[i], elementsY[i]));\n    float theta = atan((bc.y - (elementsY[i])), (bc.x - (elementsX[i])));\n    \/\/ vorticity\n    float vTheta = vortexStrengths[i] \/ r;\n    u = u + vTheta * cos(theta);\n    v = v + vTheta * sin(theta);\n    \/\/ divergence (source\/sink)\n    float vR = divergences[i] \/ r;\n    u = u + vR * cos(theta + 3.14159 \/ 2.0);\n    v = v + vR * sin(theta + 3.14159 \/ 2.0);\n  }\n  \/\/ uniform flow not utilized in this project\n  return sqrt(u * u + v * v);\n}\n\n\/\/ standard shader rgb2hsv and hsv2rgb functions\nvec3 rgb2hsv(vec3 c) {\n  vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  \/\/ get virtual screen texture at pos\n  vec2 uv = pos;\n  vec4 screenCol = texture2D(texture, uv);\n  \/\/ translate from pos to intermediate coordinates independent of pixel density\n  vec2 ic = gl_FragCoord.xy \/ (M) \/ vec2(D);\n  float noiseOffset = 0.0;\n  \/\/ scale from intermediate to base coordinates\n  vec2 bc = vec2(ic);\n  bc.x = bc.x - 0.5 - (OFFSETX \/ (Sxy.y)) + sin(noiseOffset) * noiseOffset;\n  bc.y = bc.y + 0.5 - (OFFSETY \/ (Sxy.x)) + cos(noiseOffset) * noiseOffset;\n\n  \/\/ calculate stream function and velocity potential in base coordinates\n  vec2 psiPhi = getPsiPhi(bc);\n  float psi = psiPhi.x;\n  float phi = psiPhi.y;\n\n  \/\/ initialize variables\n  float i;\n  float j; \n  vec3 flowFieldColor;\n  vec3 particleColor;\n  \/\/ assign colors based on palette\n  if (paletteIndex == 0) {\n    \/\/ Inclusion\n    i = sin(psi * psiMult + psiOffset);\n    j = cos(phi * phiMult + phiOffset);\n    flowFieldColor = vec3(j - i, j - i, i - j);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    flowFieldHSV = vec3(flowFieldHSV.r, 1.3 - abs(j) \/ 2.0, flowFieldHSV.b);\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    float limit = 0.5;\n    if (flowFieldHSV.b < limit) {\n      flowFieldHSV.g = 0.0;\n      flowFieldHSV.b = limit;\n    } else {\n      flowFieldHSV.b = limit + 3.0 * (flowFieldHSV.b - limit);\n    }\n    particleColor = hsv2rgb(vec3(flowFieldHSV.r, flowFieldHSV.g, flowFieldHSV.b));\n  } else if (paletteIndex == 1) {\n    \/\/ Rainbow\n    i = cos(psi * psiMult + psiOffset \/ 4.0) * 0.2;\n    j = cos(phi * phiMult + phiOffset \/ 4.0) * 0.2;\n    flowFieldColor = hsv2rgb(vec3(fract((i + j) \/ 2.0 * 3.1415926535), saturation, 1.0));\n    particleColor = hsv2rgb(vec3(fract((i + j) \/ 2.0 * 3.1415926535), 0.3, 1.0));\n  } else if (paletteIndex == 2) {\n    \/\/ Skip\n    i = cos(psi * psiMult \/ 2.0 + psiOffset);\n    j = sin(phi * phiMult + phiOffset);\n    flowFieldColor = vec3(cos(psi * psiMult \/ 2.0), j, i);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    float s = saturation;\n    if (migraine) {\n      if (i > 0.75) {\n        s = (3.0 + saturation) - (4.0 * i);\n      }\n    }\n    flowFieldHSV = vec3(fract(flowFieldHSV.r + cos(psi * psiMult)), s, 1.0);\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    particleColor = hsv2rgb(vec3(flowFieldHSV.r, min(s, 0.3), 1.0));\n  } else if (paletteIndex == 3) {\n    \/\/ Form\n    i = cos(psi * psiMult + 0.34 * psiOffset);\n    j = cos(phi * phiMult + phiOffset);\n    float i2 = cos(psi * psiMult + 0.44 * psiOffset + fract(j));\n    flowFieldColor = vec3(0, -i + j, -i);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    float v = 1.0 - j;\n    float h = flowFieldHSV.r + i;\n    float s = saturation;\n    if (j < 0.0) {\n      v = 0.7 - 0.5 + 0.5 * i2;\n      s = 0.2 + 0.5 - 0.5 * i2;\n      h = fract(0.5 * j + 0.25 * i + psiOffset * 0.11);\n    }\n    flowFieldHSV = vec3(h, s, v);\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    if (j < 0.0) {\n      flowFieldHSV.g = saturation - 0.2;\n      flowFieldHSV.b = 1.0;\n    }\n    particleColor = hsv2rgb(flowFieldHSV);\n  } else if (paletteIndex == 4) {\n    \/\/ Overload\n    i = cos(psi * psiMult + 0.94 * psiOffset);\n    j = cos(phi * phiMult + phiOffset);\n    flowFieldColor = vec3(0, -i + j, -i);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    float v = 1.0 - j;\n    if (j > 0.0) {\n      v = abs(i + j);\n    } else {\n      v = 1.0;\n    }\n    flowFieldHSV = vec3(flowFieldHSV.r + i, saturation, v);\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    if (j < 0.0) {\n      flowFieldHSV.g = saturation - 0.2;\n      flowFieldHSV.b = 1.0;\n    }\n    particleColor = hsv2rgb(flowFieldHSV);\n  } else if (paletteIndex == 5) {\n    \/\/ Step\n    i = cos(psi * 6.0 + psiOffset \/ 10.0) * 0.2;\n    j = cos(phi + phiOffset \/ 10.0);\n    flowFieldColor = vec3(i, j + 0.85, 0.0);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    flowFieldHSV.r = flowFieldHSV.r + cos(psi * psiMult + psiOffset \/ 10.0);\n    flowFieldHSV.g = flowFieldHSV.g * 0.75;\n    flowFieldHSV.b = flowFieldHSV.b * 0.5;\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    particleColor = hsv2rgb(vec3(flowFieldHSV.r, flowFieldHSV.g - 0.1, flowFieldHSV.b + 0.1));\n  } else {\n    \/\/ Monochromatic\n    i = cos(psi * psiMult + 0.94 * psiOffset);\n    j = cos(phi * phiMult + phiOffset);\n    float k = cos(phi * phiMult + phiOffset + 3.14);\n    flowFieldColor = vec3(1.0, 0, 0);\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    float v;\n    if (j > 0.0) {\n      v = abs(i + j) + fract(0.5 * j + 0.25 * i + 0.5 + psiOffset * 0.11);\n    } else {\n      v = abs(k);\n    }\n    float actualStaticOffset = floor(hueStaticOffset * 6.0) \/ 6.0;\n    if (abs(actualStaticOffset - 0.5) < 0.01) {\n      actualStaticOffset = 0.6666;\n    }\n    if (abs(actualStaticOffset - 0.8333) < 0.01) {\n      actualStaticOffset = 0.0;\n    }\n    flowFieldHSV = vec3(fract(actualStaticOffset), 0.7, v);\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    if (j < 0.0) {\n      flowFieldHSV.g = saturation - 0.2;\n      flowFieldHSV.b = 1.0;\n    }\n    particleColor = hsv2rgb(flowFieldHSV);\n  } \n  \/\/ POST PROCESSING\n  \/\/ Remap hue from red to blue only, emulating default MATLAB contour plot behavior\n  if (limitHueMatlab) {\n    vec3 flowFieldHSV = rgb2hsv(flowFieldColor);\n    if (flowFieldHSV.r > 0.5) {\n      flowFieldHSV.r = 0.5 - (flowFieldHSV.r - 0.5);\n    }\n    flowFieldHSV.r = flowFieldHSV.r * 0.666 \/ 0.500;\n    flowFieldColor = hsv2rgb(flowFieldHSV);\n    vec3 particleHSV = rgb2hsv(particleColor);\n    if (particleHSV.r > 0.5) {\n      particleHSV.r = 0.5 - (particleHSV.r - 0.5);\n    }\n    particleHSV.r = particleHSV.r * 0.666 \/ 0.500;\n    particleColor = hsv2rgb(particleHSV);\n  }\n\n  \/\/ DRAW\n  if (screenCol.r < 0.05) {\n    \/\/ DRAW FLOW FIELD\n    gl_FragColor = vec4(flowFieldColor, 1.0);\n  } else {\n    \/\/ DRAW PARTICLE\n    gl_FragColor = vec4(mix(particleColor, flowFieldColor, 1.0 - (screenCol.r+screenCol.g) \/ 2.0), 1.0);\n  }\n}\n`;\nconst TARGET_FRAME_RATE = 60;\n\n\/\/ --- COORDINATE SYSTEMS ---\n\/\/ base coordinate system is 1000 x 1000\nvar BASE_SIZE = 1000;\n\/\/ translate to window size\nvar WIDTH = window.innerWidth;\nvar HEIGHT = window.innerHeight;\nvar DIM = Math.min(WIDTH, HEIGHT);\nvar S = DIM \/ BASE_SIZE;\nvar SX = WIDTH \/ BASE_SIZE;\nvar SY = HEIGHT \/ BASE_SIZE;\n\/\/ we center the base coordinate system on the screen\nvar OFFSETX = (WIDTH - DIM) \/ 2;\nvar OFFSETY = (HEIGHT - DIM) \/ 2;\n\n\/\/ utility functions to return window coordinate from base coordinate\nfunction M(value) {\n  return value * S;\n}\nfunction Mx(x) {\n  return x * S + OFFSETX;\n}\nfunction My(y) {\n  return y * S + OFFSETY;\n}\n\n\/\/ --- DEFAULT CONFIGURATION ---\nconst CONFIG = {\n  backCol: [0, 0, 0],\n  numParticles: [350, 1000],\n  probabilityNoParticles: 0.1,\n  \/\/ a multiplier that applies to the particle velocities only\n  numElements: [2, 4],\n  numStaticElements: [2, 3],\n  \/\/ note: vortex strength is circulation \/ 2PI\n  vortexStrengthRange: [-23, 23],\n  vortexStrengthMultiplier: 1,\n  allowZeroVortexStrength: true,\n  useVorticityInPhi: false,\n  \/\/ source\/sink\n  probabilityElementsMayDiverge: 0.9,\n  probabilityElementHasDivergence: 1.0,\n  divergenceRange: [-10, 10],\n  divergenceStrengthMultiplier: 1,\n  allowZeroDivergence: false,\n  useDivergenceInPsi: false,\n  \/\/ other\n  phiMult: [1, 1],\n  \/\/ element positioning\n  elementBorder: 0.1,\n  \/\/ particles\n  particleVelocityMult: 6,\n  maxParticleSpeed: 10,\n  particleFrameChanceOfRespawn: 0.01,\n  respawnRadiusIncrement: 0.05,\n  respawnRadiusDecrement: 0.03,\n  particleStrokeWeights: [1, 3, 5],\n  particleStrokeWeightProbabilities: [0.15, 0.75, 0.1],\n  backgroundAlpha: [10, 40],\n};\n\n\/\/ returns a choice from choices based on probabilities (which must sum to 1)\nfunction getWeightedChoice(choices, probabilities) {\n  let x = R.random_dec();\n  let i = 0;\n  let sum_ = 0.0;\n  while (i < probabilities.length - 1) {\n    sum_ += probabilities[i];\n    if (x < sum_) {\n      break;\n    }\n    i++;\n  }\n  return choices[i];\n}\n\n\/\/ --- COLOR PALETTES ---\nPALETTES = [\n  {\n    name: \"Inclusion\",\n    index: 0,\n    psiMult: [1, 1],\n    psiOffsetMultiplier: [1.0, 1.0],\n    phiOffsetMultiplier: \"equal\",\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n  },\n  {\n    name: \"Rainbow\",\n    index: 1,\n    psiMult: [0.1, 0.1],\n    psiOffsetMultiplier: [0.1, 0.4],\n    phiOffsetMultiplier: \"equal\",\n    saturation: [0.75, 0.85],\n    numStaticElements: [4, 4],\n    noParticles: false,\n    maxParticleSpeed: 5.0,\n  },\n  {\n    name: \"Skip\",\n    index: 2,\n    psiMult: [0.05, 0.1],\n    psiOffsetMultiplier: [0.2, 0.25],\n    phiOffsetMultiplier: \"equal\",\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n    hueStaticOffset: [0.0, 1.0],\n    probabilityMigraine: 0.1,\n    saturation: [0.75, 0.85],\n    limitHueMatlab: true,\n    maxParticleSpeed: 5.0,\n  },\n  {\n    name: \"Form\",\n    index: 3,\n    psiMult: [0.05, 0.1],\n    psiOffsetMultiplier: [0.2, 0.6],\n    phiOffsetMultiplier: \"equal\",\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n    maxParticleSpeed: 5.0,\n    saturation: [0.5, 0.8],\n    probabilityHighFlowElements: 0.15,\n    highFlowElementsRange: [5, 14],\n    limitHueMatlab: true,\n  },\n  {\n    name: \"Overload\",\n    index: 4,\n    psiMult: [0.05, 0.1],\n    psiOffsetMultiplier: [0.04, 0.2],\n    phiOffsetMultiplier: \"equal\",\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n    maxParticleSpeed: 5.0,\n    saturation: [0.5, 0.8],\n    probabilityHighFlowElements: 0.15,\n    highFlowElementsRange: [5, 14],\n  },\n  {\n    name: \"Step\",\n    index: 5,\n    psiMult: [0.03, 0.03],\n    psiOffsetMultiplier: [0.5, 0.5],\n    phiOffsetMultiplier: [1, 1],\n    noParticles: false,\n    alwaysParticles: true,\n    particleVelocityMult: 20.0,\n    maxParticleSpeed: 30.0,\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n    saturation: [0.75, 0.85],\n    limitHueMatlab: true,\n  },\n  {\n    name: \"Monochromatic\",\n    index: 6,\n    psiMult: [0.05, 0.1],\n    psiOffsetMultiplier: [0.04, 0.2],\n    phiOffsetMultiplier: \"equal\",\n    \/\/ require divergence\n    probabilityElementsMayDiverge: 1.0,\n    maxParticleSpeed: 5.0,\n    hueStaticOffset: [0.0, 1.0],\n    probabilityHighFlowElements: 0.2,\n    highFlowElementsRange: [5, 14],\n  },\n];\n\nPALETTE_PROBABILITIES = [\n  0.0, \/\/ 0 Inclusion (only token #21)\n  0.2, \/\/ 1 Rainbow\n  0.1, \/\/ 2 Skip\n  0.2, \/\/ 3 Form\n  0.3, \/\/ 4 Overload\n  0.1, \/\/ 5 Step\n  0.1, \/\/ 6 Monochromatic\n];\n\/\/ determine the color palette\nlet paletteRand = R.random_dec();\nlet paletteIndex = 0;\nlet _sum = 0;\nwhile (paletteRand > _sum) {\n  _sum += PALETTE_PROBABILITIES[paletteIndex];\n  paletteIndex++;\n}\n\/\/ token #21 is always Inclusion\nif (tokenData.tokenId % 1_000_000 == 21) {\n  paletteIndex = 1; \/\/ Inclusion's index plus 1\n}\nlet PALETTE = PALETTES[paletteIndex - 1];\nconsole.log(\"Flows: Token ID = \", tokenData.tokenId.toString());\nconsole.log(\"Flows: Palette = \", PALETTE.name);\n\n\/\/ helper function to get a palette override or default scalar value\nfunction getPaletteOrDefault(propName) {\n  return PALETTE[propName] !== undefined ? PALETTE[propName] : CONFIG[propName];\n}\n\n\/\/ helper function to get random value between two points\nfunction randInterp(range, useParabolic) {\n  let interpDec = R.random_dec();\n  if (useParabolic) {\n    interpDec = interpDec * interpDec;\n  }\n  return range[0] + interpDec * (range[1] - range[0]);\n}\n\n\/\/ initialize the configuration details\nconst potentialParticles = PALETTE.numParticlesOverride\n  ? R.random_int(...PALETTE.numParticlesOverride)\n  : R.random_int(...CONFIG.numParticles);\nconst NUM_PARTICLES = PALETTE.noParticles\n  ? 0\n  : R.random_bool(CONFIG.probabilityNoParticles) && !PALETTE.alwaysParticles\n  ? 0\n  : potentialParticles;\nCONFIG.particleStrokeWeightProbabilities = getPaletteOrDefault(\n  \"particleStrokeWeightProbabilities\"\n);\nif (NUM_PARTICLES > 0) {\n  CONFIG.particleStrokeWeight = getWeightedChoice(\n    CONFIG.particleStrokeWeights,\n    CONFIG.particleStrokeWeightProbabilities\n  );\n  const PARTICLE_SIZE_LABELS = {\n    1: \"Small\",\n    3: \"Normal\",\n    5: \"Large\",\n  };\n  console.log(\n    \"Flows: Particle Size = \",\n    PARTICLE_SIZE_LABELS[CONFIG.particleStrokeWeight]\n  );\n}\nCONFIG.particleVelocityMult = getPaletteOrDefault(\"particleVelocityMult\");\nCONFIG.maxParticleSpeed = getPaletteOrDefault(\"maxParticleSpeed\");\nCONFIG.probabilityElementsMayDiverge = getPaletteOrDefault(\n  \"probabilityElementsMayDiverge\"\n);\nCONFIG.particleFrameChanceOfRespawn = getPaletteOrDefault(\n  \"particleFrameChanceOfRespawn\"\n);\nCONFIG.elementsMayDiverge = R.random_bool(CONFIG.probabilityElementsMayDiverge);\nCONFIG.vortexStrengthRange = getPaletteOrDefault(\"vortexStrengthRange\");\nCONFIG.divergenceRange = getPaletteOrDefault(\"divergenceRange\");\nCONFIG.psiMult = randInterp(PALETTE.psiMult, true);\nCONFIG.phiMult = randInterp(CONFIG.phiMult, true);\nCONFIG.useVorticityInPhi = getPaletteOrDefault(\"useVorticityInPhi\");\nCONFIG.useDivergenceInPsi = getPaletteOrDefault(\"useDivergenceInPsi\");\nCONFIG.backgroundAlpha = randInterp(CONFIG.backgroundAlpha, true);\nCONFIG.psiOffsetMultiplier = randInterp(PALETTE.psiOffsetMultiplier, false);\nif (PALETTE.phiOffsetMultiplier == \"equal\") {\n  CONFIG.phiOffsetMultiplier = CONFIG.psiOffsetMultiplier;\n} else {\n  CONFIG.phiOffsetMultiplier = randInterp(PALETTE.phiOffsetMultiplier, false);\n}\nCONFIG.hueStaticOffset =\n  PALETTE.hueStaticOffset != undefined\n    ? randInterp(PALETTE.hueStaticOffset, false)\n    : 0.0;\nCONFIG.migraine =\n  PALETTE.probabilityMigraine != undefined\n    ? R.random_bool(PALETTE.probabilityMigraine)\n    : false;\nCONFIG.saturation =\n  PALETTE.saturation != undefined ? randInterp(PALETTE.saturation, false) : 0.0;\n\n\/\/ --- ELEMENT CONFIGS ---\nconst ELEMENTS = [];\n\/\/ populate vortex arrays\nlet NUM_ELEMENTS = R.random_int(...CONFIG.numElements);\nif (PALETTE.probabilityHighFlowElements != undefined) {\n  if (R.random_bool(PALETTE.probabilityHighFlowElements)) {\n    NUM_ELEMENTS = R.random_int(...PALETTE.highFlowElementsRange);\n  }\n}\nCONFIG.numStaticElements = getPaletteOrDefault(\"numStaticElements\");\nlet NUM_STATIC_ELEMENTS = Math.min(\n  NUM_ELEMENTS,\n  R.random_int(...CONFIG.numStaticElements)\n);\nif (CONFIG.elementsMayDiverge) {\n  NUM_STATIC_ELEMENTS = NUM_ELEMENTS;\n}\nconsole.log(\"Flows: Num Flow Elements = \", NUM_ELEMENTS.toString());\n\n\/\/ utility function to get target time in seconds since start.\n\/\/ assumes that TARGET_FRAME_RATE is set, and ensures that project's\n\/\/ display is never a function of display actual frame rate\nfunction time_() {\n  try {\n    return frameCount \/ TARGET_FRAME_RATE;\n  } catch (error) {\n    return 0;\n  }\n}\n\nclass Element {\n  constructor(isStatic) {\n    this.initialize();\n    this.isStatic = isStatic;\n  }\n\n  \/\/ sets vorticity, divergene, and initial position of element\n  initialize() {\n    this.respawn();\n    \/\/ assign vorticity\n    let _vortexStrength = 0;\n    while (_vortexStrength === 0) {\n      _vortexStrength = R.random_int(...CONFIG.vortexStrengthRange);\n      if (CONFIG.allowZeroVortexStrength) {\n        break;\n      }\n    }\n    this.vortexStrength = _vortexStrength * CONFIG.vortexStrengthMultiplier;\n    \/\/ assign divergence\n    let _divergence = 0;\n    if (\n      CONFIG.elementsMayDiverge &&\n      R.random_bool(CONFIG.probabilityElementHasDivergence)\n    ) {\n      while (_divergence === 0) {\n        _divergence = R.random_int(...CONFIG.divergenceRange);\n        if (CONFIG.allowZeroDivergence) {\n          break;\n        }\n      }\n    }\n    this.divergence = _divergence * CONFIG.divergenceStrengthMultiplier;\n  }\n\n  _getRandomValidPosition() {\n    return R.random_int(\n      BASE_SIZE * CONFIG.elementBorder,\n      BASE_SIZE * (1 - CONFIG.elementBorder)\n    );\n  }\n\n  \/\/ changes position of element\n  respawn() {\n    this.x = this._getRandomValidPosition();\n    this.y = this._getRandomValidPosition();\n  }\n\n  \/\/ operates in base coordinates\n  getVelocity(_atPosition) {\n    \/\/ get radial distance from vortex to point\n    const r = pointDistance(this.x, this.y, _atPosition[0], _atPosition[1]);\n    if (r === 0) {\n      \/\/ avoid divide by zero, very, very edge case, return zero velocity\n      return [0, 0];\n    }\n    \/\/ calc theta, 90 degrees\n    const theta =\n      Math.PI \/ 2 + pointAngle(this.x, this.y, _atPosition[0], _atPosition[1]);\n    \/\/ --- Vorticity ---\n    const v_theta = this.getVortexStrength() \/ r;\n    \/\/ return velocity in cartesian reference frame, with particle gamma multiplier\n    let vx = v_theta * Math.cos(theta) * CONFIG.particleVelocityMult;\n    let vy = v_theta * Math.sin(theta) * CONFIG.particleVelocityMult;\n    \/\/ --- Source\/Sink ---\n    const v_r = this.getDivergence() \/ r;\n    vx += v_r * Math.cos(theta + Math.PI \/ 2) * CONFIG.particleVelocityMult;\n    vy += v_r * Math.sin(theta + Math.PI \/ 2) * CONFIG.particleVelocityMult;\n    \/\/ --- Uniform Flow not utilized in this project ---\n    return [vx, vy];\n  }\n\n  getVortexStrength() {\n    return this.vortexStrength;\n  }\n\n  getDivergence() {\n    return this.divergence;\n  }\n}\n\n\/\/ populate global elements array\nfor (let i = 0; i < NUM_ELEMENTS; i++) {\n  const _isStatic = i < NUM_STATIC_ELEMENTS;\n  ELEMENTS.push(new Element(_isStatic));\n}\n\n\/\/ shift view to geometric center of all flow elements\nlet centerX = 0;\nlet centerY = 0;\nfor (let i = 0; i < NUM_ELEMENTS; i++) {\n  centerX += ELEMENTS[i].x;\n  centerY += ELEMENTS[i].y;\n}\ncenterX \/= NUM_ELEMENTS;\ncenterY \/= NUM_ELEMENTS;\nfor (let i = 0; i < NUM_ELEMENTS; i++) {\n  ELEMENTS[i].x -= centerX - BASE_SIZE \/ 2;\n  ELEMENTS[i].y -= centerY - BASE_SIZE \/ 2;\n}\n\n\/\/ returns distance between two points\nconst pointDistance = (x1, y1, x2, y2) => {\n  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n};\n\n\/\/ returns angle in radians between two points\nconst pointAngle = (x1, y1, x2, y2) => {\n  return Math.atan2(y2 - y1, x2 - x1);\n};\n\n\/\/ returns velocity [u, v] at a point due to all flow elements.\n\/\/ operates in base coordinates\nfunction getVelocityAtPoint(_position) {\n  let v = [0, 0];\n  for (let i = 0; i < NUM_ELEMENTS; i++) {\n    const elV = ELEMENTS[i].getVelocity(_position);\n    v[0] += elV[0];\n    v[1] += elV[1];\n  }\n  return v;\n}\n\n\/\/ updates position of all non-static vortices.\n\/\/ operates in base coordinates\nfunction updateElementPositions() {\n  DxDy = [];\n  for (let i = 0; i < NUM_ELEMENTS; i++) {\n    const DxDyi = [0, 0];\n    if (!ELEMENTS[i].isStatic) {\n      \/\/ calculate velocity at element due to all other elements\n      for (let j = 0; j < NUM_ELEMENTS; j++) {\n        if (i != j) {\n          const elV = ELEMENTS[j].getVelocity([ELEMENTS[i].x, ELEMENTS[i].y]);\n          DxDyi[0] += elV[0];\n          DxDyi[1] += elV[1];\n        }\n      }\n    }\n    DxDy.push(DxDyi);\n  }\n  \/\/ update positions\n  for (let i = 0; i < NUM_ELEMENTS; i++) {\n    ELEMENTS[i].x += DxDy[i][0];\n    ELEMENTS[i].y += DxDy[i][1];\n  }\n}\n\nclass Particle {\n  constructor() {\n    this.respawn(true);\n  }\n\n  beginRespawn() {\n    this.isRespawning = true;\n  }\n\n  respawn(instantCreate) {\n    \/\/ restart line end point\n    this.xlast = undefined;\n    this.ylast = undefined;\n    this.ulast = undefined;\n    this.vlast = undefined;\n    \/\/ update position\n    this.x = R.random_dec() * 1.88 * BASE_SIZE - BASE_SIZE * 0.44;\n    this.y = R.random_dec() * 1.88 * BASE_SIZE - BASE_SIZE * 0.44;\n    \/\/ update velocity\n    const vel = getVelocityAtPoint([this.x, this.y]);\n    this.u = vel[0];\n    this.v = vel[1];\n    if (instantCreate) {\n      this._radiusMultiplier = 1.0;\n    }\n    this.isRespawning = false;\n  }\n\n  updatePosition() {\n    const vel = getVelocityAtPoint([this.x, this.y]);\n    \/\/ check if particle is moving too fast\n    if (Math.sqrt(vel[0] ** 2 + vel[1] ** 2) > CONFIG.maxParticleSpeed) {\n      this._radiusMultiplier = 0.0;\n      this.respawn(false);\n    } else {\n      \/\/ update previous position and velocity\n      this.xlast = this.x;\n      this.ylast = this.y;\n      this.ulast = this.u;\n      this.vlast = this.v;\n      this.x += vel[0];\n      this.y += vel[1];\n      this.u = vel[0];\n      this.v = vel[1];\n    }\n  }\n\n  draw() {\n    if (this.xlast != undefined) {\n      screen.strokeWeight(\n        M(CONFIG.particleStrokeWeight * this._radiusMultiplier)\n      );\n      screen.curve(\n        Mx(this.xlast - this.ulast),\n        My(this.ylast - this.vlast),\n        Mx(this.xlast),\n        My(this.ylast),\n        Mx(this.x),\n        My(this.y),\n        Mx(this.x + this.u),\n        My(this.y + this.v)\n      );\n    }\n    if (R.random_dec() < CONFIG.particleFrameChanceOfRespawn) {\n      this.beginRespawn();\n    }\n  }\n\n  frameChecks() {\n    if (this.isRespawning) {\n      this._radiusMultiplier -= CONFIG.respawnRadiusDecrement;\n      if (this._radiusMultiplier <= 0) {\n        this.respawn(false);\n      }\n    } else if (this._radiusMultiplier < 1.0) {\n      this._radiusMultiplier = Math.min(\n        1.0,\n        this._radiusMultiplier + CONFIG.respawnRadiusIncrement\n      );\n    }\n  }\n}\n\nconst PARTICLES = [];\nfor (let i = 0; i < NUM_PARTICLES; i++) {\n  PARTICLES.push(new Particle());\n}\n\nfunction setup() {\n  \/\/ create WEBGL canvas\n  createCanvas(WIDTH, HEIGHT, WEBGL);\n  stream = createShader(vertexShader, fragmentShader);\n  \/\/ create off-screen screen buffer\n  screen = createGraphics(WIDTH, HEIGHT);\n  \/\/ define screen defaults\n  screen.background(0);\n  screen.stroke(255);\n  screen.strokeWeight(M(CONFIG.particleStrokeWeight));\n  \/\/ set pixel density to display density for animated piece\n  let density = displayDensity();\n  pixelDensity(density);\n\n  \/\/ set active shader\n  shader(stream);\n\n  \/\/ set shader resolution-related uniforms\n  stream.setUniform(\"M\", [M(1), M(1)]);\n  stream.setUniform(\"Sxy\", [SX, SY]);\n  stream.setUniform(\"D\", density);\n  stream.setUniform(\"WIDTH\", WIDTH);\n  stream.setUniform(\"HEIGHT\", HEIGHT);\n  stream.setUniform(\"OFFSETX\", OFFSETX);\n  stream.setUniform(\"OFFSETY\", OFFSETY);\n  \/\/ set shader vortex-related uniforms\n  stream.setUniform(\"activeElements\", ELEMENTS.length);\n  stream.setUniform(\"useVorticityInPhi\", CONFIG.useVorticityInPhi);\n  stream.setUniform(\"useDivergenceInPsi\", CONFIG.useDivergenceInPsi);\n  frameRate(TARGET_FRAME_RATE);\n\n  stream.setUniform(\"paletteIndex\", PALETTE.index);\n  stream.setUniform(\"limitHueMatlab\", PALETTE.limitHueMatlab || false);\n\n  \/\/ other constants\n  stream.setUniform(\"hueStaticOffset\", CONFIG.hueStaticOffset);\n  stream.setUniform(\"migraine\", CONFIG.migraine);\n  stream.setUniform(\"saturation\", CONFIG.saturation);\n}\n\nfunction draw() {\n  \/\/ update vortex positions and assign in shader\n  updateElementPositions();\n\n  \/\/ define vortex positions in shader, in base coordinates\n  stream.setUniform(\"elementsX\", [...ELEMENTS.map((_el) => _el.x)]);\n  stream.setUniform(\"elementsY\", [...ELEMENTS.map((_el) => _el.y)]);\n  stream.setUniform(\"vortexStrengths\", [\n    ...ELEMENTS.map((_el) => _el.getVortexStrength()),\n  ]);\n  stream.setUniform(\"divergences\", [\n    ...ELEMENTS.map((_el) => _el.getDivergence()),\n  ]);\n\n  \/\/ set multipliers and offsets\n  stream.setUniform(\"psiMult\", CONFIG.psiMult);\n  stream.setUniform(\"phiMult\", CONFIG.phiMult);\n  stream.setUniform(\"phiOffset\", -time_() * CONFIG.phiOffsetMultiplier);\n  stream.setUniform(\"psiOffset\", -time_() * CONFIG.psiOffsetMultiplier);\n\n  \/\/ draw background\n  screen.background(0, CONFIG.backgroundAlpha);\n\n  for (let i = 0; i < NUM_PARTICLES; i++) {\n    PARTICLES[i].updatePosition();\n    PARTICLES[i].frameChecks();\n    PARTICLES[i].draw();\n  }\n  \/\/ Give the shader a surface to draw on;\n  stream.setUniform(\"texture\", screen);\n  rect(-WIDTH \/ 2, -HEIGHT \/ 2, WIDTH, HEIGHT);\n}\n",
  "tokens" : [
    {
      "hash" : "0x1eb79d1f09f561d01a7a4b0a24bb7e05bbf7ec6db31a0d9618c624ceb14584d4",
      "id" : "435000058"
    },
    {
      "hash" : "0x4165e7ecf07b2c2ce66de38c9db8ff8ae40f4123ac73537087b51719e2fa5888",
      "id" : "435000088"
    },
    {
      "hash" : "0x5a10781625192f3e8b861af4116d3ef5e6071d82429b12822899f14eae9280a8",
      "id" : "435000017"
    },
    {
      "hash" : "0xa13a8e6c1e95d0b15514b2d10d181f2912121e768f134c458cf09af2c6268bbf",
      "id" : "435000078"
    },
    {
      "hash" : "0xb23fc32111b21e859682fdc7d4aa1861b722278f39e8208b04e88d28ac29094e",
      "id" : "435000011"
    },
    {
      "hash" : "0x4479ee4e6db81638b7170ec268544547ee1042edde7cf8c9f2a621ad2124b86c",
      "id" : "435000096"
    },
    {
      "hash" : "0x9ebcaeb10598f7ee33d8111519a425ae3df42caf0e3e7184f90a22456e412b16",
      "id" : "435000097"
    },
    {
      "hash" : "0x41c8c7670b359bb6758dc4942d0d194571369cfede0468a2d99a75b4b9317e52",
      "id" : "435000067"
    },
    {
      "hash" : "0x9b6bfde9126369c9b0328d9b85810d1c8da807f4e050ceb004ff63218f68c571",
      "id" : "435000016"
    },
    {
      "hash" : "0x7306beb1b417c885d78478e0efcfdc80bf6890f5de0185bb11495b0c1f36d6ea",
      "id" : "435000008"
    },
    {
      "hash" : "0xa81368c6d126167a672014d579105403f030faedd117398f4c1201ffe5166f31",
      "id" : "435000050"
    },
    {
      "hash" : "0xf1f59ffa44f87b2553d9bb9ea9e485834d555096730e202797684881f6cfae77",
      "id" : "435000081"
    },
    {
      "hash" : "0x6208beef01f654b609cfa5dc0b4784a49ddda6bf971f226562859d9797eed6f1",
      "id" : "435000094"
    },
    {
      "hash" : "0x52fed9505b4210a663dec72c4404d6d3340450373ae55f2fb96730461251506a",
      "id" : "435000075"
    },
    {
      "hash" : "0xc5decf112de92c00379d882e421f7406ff3984e616d061ce04a85f3dc972419e",
      "id" : "435000063"
    },
    {
      "hash" : "0x30703091ac12ec30fbded765ade2ee5ddc41251cb6fa9dc4d30a67a7d843354f",
      "id" : "435000077"
    },
    {
      "hash" : "0xe8390d1f3abf7aaf95729bc5dc1cb14dfd048e0e012f1d260d421bfb52d9e066",
      "id" : "435000074"
    },
    {
      "hash" : "0x5d214da87e0006bf74c30284889c8afd2039f3cba4d8baddb6f262fc064f23f8",
      "id" : "435000007"
    },
    {
      "hash" : "0x4ca7d093c6923c11efa99d468929b997b19199c5596dbb60441aa582c700320b",
      "id" : "435000089"
    },
    {
      "hash" : "0x8de312a39c14b3ea35c65a68ec91b8d606eee74e0bbb8d4b8d1f55038b33aec3",
      "id" : "435000031"
    },
    {
      "hash" : "0xfb23ddd1a5b840107d87ec6c5188220e99855b9ece885cc4b4937ae3ec29c1be",
      "id" : "435000019"
    },
    {
      "hash" : "0xb03b9e6a21b7fc4247f2154ee3697513f9b59c8670ab477a0058e00841448af7",
      "id" : "435000010"
    },
    {
      "hash" : "0x0f52babfba07add65bb89a677bdafe53f6f5f80f1a500347ae49d4724b658766",
      "id" : "435000085"
    },
    {
      "hash" : "0xc50654c683346f45dbd505ee522aeb60e7cd6f888b4368c0a1f46f6f2c3f2e4b",
      "id" : "435000086"
    },
    {
      "hash" : "0xae43d6db64b7d6811e5494edcd42e34e9ae4c77162ef992173d0f8a6f1fd6bd0",
      "id" : "435000027"
    },
    {
      "hash" : "0x4a48d3050cf26886e60d3a2c525adbc8dabdec080fdd255bf8ff07242d15b29d",
      "id" : "435000026"
    },
    {
      "hash" : "0x403fb2f7b4f25bb7dfeecc2e92a254ec8c2e5f636582d04b112dd6f1fe38a5f6",
      "id" : "435000093"
    },
    {
      "hash" : "0xb4312463bf8b02ab41be671f6fece2aa61827525c8b1f67e3e8531c8b110cef9",
      "id" : "435000087"
    },
    {
      "hash" : "0x1a5087a6e497767a72258b9bc6b1c286aa4b566e27246cec42df6372676376f8",
      "id" : "435000057"
    },
    {
      "hash" : "0x9a1ffb715816a4dbe3509fdb5fa430ac51daf26e31acddd4e97fafee33e8bb73",
      "id" : "435000006"
    },
    {
      "hash" : "0x8aae8b1111ff6dfe5f6de9d278f91723deb1bcf8fa1d1e5e50f170e32b538e0f",
      "id" : "435000003"
    },
    {
      "hash" : "0x034a2ef46eb070097480bd28e8bc206e57d347399411060348e469af9ce75491",
      "id" : "435000040"
    },
    {
      "hash" : "0xff04d2c1f85a77247627343685cce0766f4fe58dea1053bbe13369084398f0d2",
      "id" : "435000053"
    },
    {
      "hash" : "0xe294701321a5b5c3d6a3c1b78cd0cdddb74b14012c20dc808837c566f4f00686",
      "id" : "435000041"
    },
    {
      "hash" : "0xc6aedb003c8a0d52c8306fa089ff6e4794542853ffba1e94fdc71a95b0284081",
      "id" : "435000052"
    },
    {
      "hash" : "0x3eb275581b09bf478a43f64794261340298b0363c17a3987071276d5257f82d6",
      "id" : "435000080"
    },
    {
      "hash" : "0xc700d681622c826278c01c5841867d3cd9ebe433077ade63675bbff7782a8c1c",
      "id" : "435000018"
    },
    {
      "hash" : "0x36f4e20200f4b3e909bd1c5bf507bae804b275fcc2c172cc562d65332f278dde",
      "id" : "435000073"
    },
    {
      "hash" : "0x67b3e6473b71552ba20ebf0a3e272dc3813eb18331a25c8ef5d513c40d04eefa",
      "id" : "435000037"
    },
    {
      "hash" : "0x341a445393c1332252283454e12eedd2061c60b4d1c411ab9cf08d1b475b115f",
      "id" : "435000065"
    },
    {
      "hash" : "0x974ccdb53da5c53d75e9c28b5514138f62ca7d77eb10c1c09e12a64d233e2f5b",
      "id" : "435000036"
    },
    {
      "hash" : "0x0e8708b46c6b378be28ebee4643ec683f30df821ce84a9fdc1d2e1917c9cbd15",
      "id" : "435000047"
    },
    {
      "hash" : "0x2ce69a02a1530c493aaffe226c8b5897b541e42341e6dc4070f313f3d5fcbf9c",
      "id" : "435000064"
    },
    {
      "hash" : "0xf82039cc4f1bfa9fcf3666f488534888b9f316bc7898da89090b0db9c2886f30",
      "id" : "435000002"
    },
    {
      "hash" : "0x2907bf249eb069967806cd9484e9b2a64a4aab36d42f4163dc9dd83555be6503",
      "id" : "435000095"
    },
    {
      "hash" : "0x540e2b2ddc4dbc35ca7f9d75f8eec6b88d663e48ce8d90a60e9ce32c25fb4bcc",
      "id" : "435000072"
    },
    {
      "hash" : "0xda7e99b9452fac602e96a5d3d104ecb611dc5b8126d1cfd04b9541df41f11b94",
      "id" : "435000035"
    },
    {
      "hash" : "0x14b9001a03111331a45fe1975b5b55f9618872e7e5848db006f748ddd5cbed43",
      "id" : "435000034"
    },
    {
      "hash" : "0x85164a6ad2c8a0fdbca625412aab65bbc8dacaa7c23064f657a464f062adde08",
      "id" : "435000059"
    },
    {
      "hash" : "0xf2e8db270f876ee7931f9399a2efdd9ad322652d7886eefb45bf4c4986d615a4",
      "id" : "435000033"
    },
    {
      "hash" : "0x71085fbd071868df89ed14562c91179fa827ba6b434998381cc4cf5c21876570",
      "id" : "435000062"
    },
    {
      "hash" : "0x3e674ff9558cd0cf8814c41b52fe244f75a6721cc2be13711b230d1441487344",
      "id" : "435000056"
    },
    {
      "hash" : "0x6cacce1496d4b4bd0365bc08f4bdd2d3d8104b345db3798983ec9b2e7de74624",
      "id" : "435000076"
    },
    {
      "hash" : "0xfa14d0fb77f367b70622b178ef5de86513cc088aaba7d9a1e5d29df5734b8e1a",
      "id" : "435000045"
    },
    {
      "hash" : "0x739da9af42137f2082c3c153d897edaac85b4e758554416c8fed0702d965a58b",
      "id" : "435000092"
    },
    {
      "hash" : "0x15ca42233c5bf4529ece9cd768bd6b3c9a035c34d69c7a0f2502f76da4149500",
      "id" : "435000004"
    },
    {
      "hash" : "0x5cf6768850385ff7dbc13b8773f171c8b77d67a946c62ac70eaf972bd6fec866",
      "id" : "435000070"
    },
    {
      "hash" : "0x75d113475764accd2431841a2d8be855d947cd05a04031e82103dd258778e5e7",
      "id" : "435000071"
    },
    {
      "hash" : "0xef5f298f6b5dfd9fd61cbc6a48bf89c3ae28f758701b562785fa75150fdb0553",
      "id" : "435000005"
    },
    {
      "hash" : "0xd8cabb87fd236fee534f3078aa309d6a49c023ee14f65cd5819679bfe77fba7c",
      "id" : "435000084"
    },
    {
      "hash" : "0xadc94c6c57aab307d793a638ca7317d6a5e9c04777664d925ebdaf890e44d3b1",
      "id" : "435000048"
    },
    {
      "hash" : "0x7e8b9618cbd6fdc91916be9b38d52695feb91b561bae1f859f14adde4fbf49fd",
      "id" : "435000079"
    },
    {
      "hash" : "0x6ca504fce1f17a5aa312bf224a7992330699d6964835a38450ce26fb405b1576",
      "id" : "435000025"
    },
    {
      "hash" : "0xce40dd2150f89a825f86ca1d14760d0744f6798d5685fa04331c189fc147d569",
      "id" : "435000083"
    },
    {
      "hash" : "0xd03f0caf9313bd6d666fb25b5450298173edff172231256b1f8faff7ede02afa",
      "id" : "435000009"
    },
    {
      "hash" : "0x44281edb0eb64bd1f4697bdb31a762c2803257346db1565b88e756660cbff750",
      "id" : "435000000"
    },
    {
      "hash" : "0x98d6f23ff0a81d41b70bf49844fa106b774ef3cf8d8a625b9c33bf0ffde6578f",
      "id" : "435000038"
    },
    {
      "hash" : "0xdeb547ec91d4c8802279776541875c5559987b7bac2c5b107e892d46810cf6d7",
      "id" : "435000015"
    },
    {
      "hash" : "0x596b25e754722c7a7881ef2f79728dbe696917423848a92a10477df466170372",
      "id" : "435000039"
    },
    {
      "hash" : "0x33b77226515d945dce2478784af676b09a9d5823590f0e67663f5c7bc3b4f113",
      "id" : "435000068"
    },
    {
      "hash" : "0xb6f7c95f5606b07351e9a80d069080359c8b1e66d42b7cc7b52da0caf4be647a",
      "id" : "435000022"
    },
    {
      "hash" : "0x594e4c0947c68873ae1dfb6eab403b53739ef33c432c6685ef1bb1ce76008c1b",
      "id" : "435000042"
    },
    {
      "hash" : "0x6396ef703da28b34d8d0a5e53de9e7d325a1c103572bb24385d7c6d702c0a94f",
      "id" : "435000043"
    },
    {
      "hash" : "0x89d30eb0aaff7f259893a7917963a166c2fef5cd6a55fdd557e55d59eaa6d857",
      "id" : "435000028"
    },
    {
      "hash" : "0xc4e629704cd589f7e489c65e88ef4fec4c1da8d9ff1cbb67acb8c54349f834ae",
      "id" : "435000055"
    },
    {
      "hash" : "0x6589f6016c149b091ac25578c9d2ee364542ab8ac3009e2f3a7545702819f85e",
      "id" : "435000001"
    },
    {
      "hash" : "0x3001ab256d66f57c97cfeb34363a109c95a11a0771a9458c640a1d6b70925777",
      "id" : "435000012"
    },
    {
      "hash" : "0x9666d5d0644df34eee354b1736c729e41f46e037d686901ffad52d7d469a56ea",
      "id" : "435000013"
    },
    {
      "hash" : "0x8db3191bc571459fb5dac124a1cf0017975a3a864f86b5f35825f4bea096378d",
      "id" : "435000014"
    },
    {
      "hash" : "0x48a668c4ccb6eb2901e8a8e88912894b3e62369bd96d2887f5468679dcec9780",
      "id" : "435000021"
    },
    {
      "hash" : "0xc17077378abc9343cf3ae9fea9b0cb92bf6cefdc977954eaa6f88abee0965f77",
      "id" : "435000023"
    },
    {
      "hash" : "0xfb4b4ba275a06ebc58fb4848b4fdc1ef8956c5c0528e78a3ee0e002e66083870",
      "id" : "435000029"
    },
    {
      "hash" : "0xa93988ffd6e901b8b45fe84eabcd50f1146aaca5132e6cd397a2d373f1f1f55a",
      "id" : "435000030"
    },
    {
      "hash" : "0x6abdb8a5cd4b04ec2ddbe3b87fc2f4cc1fb4025089d1ad1b0c615675047ae5ea",
      "id" : "435000046"
    },
    {
      "hash" : "0x2706131b707444b8147de541f94a9f7fd8897496185c8a7126cbcdb631976d84",
      "id" : "435000049"
    },
    {
      "hash" : "0x72d562c895b829e7d09de07a968ee55441d13885b6ecc34724c742ef53ace3a0",
      "id" : "435000054"
    },
    {
      "hash" : "0xa4358cafc4dbeb75ab275962f536ba4198895f5e0576d14a89121f14f388784d",
      "id" : "435000060"
    },
    {
      "hash" : "0x9d06eaedeea48b4aa1b74051734c191b9e85fac7cd67b551cbcee8448fa1ffe9",
      "id" : "435000061"
    },
    {
      "hash" : "0x5a5f33c5ff8fbf3bf012c8349ca10d26b5566dcf4e7c92254124e277c1a6b18d",
      "id" : "435000066"
    },
    {
      "hash" : "0x035a08b3c897bedbdf736a91d329de31e058883c2e3b03bbede0d13c665f31fc",
      "id" : "435000069"
    },
    {
      "hash" : "0xf51e252eccc8910e270bb20c88acfa1d3e7748dcca8cfee175ad4c25c781acc1",
      "id" : "435000082"
    },
    {
      "hash" : "0xc1c6a656b51070f10913c5e10c5f6a49b626ab2dac04a873972b3fc45f6861d5",
      "id" : "435000090"
    },
    {
      "hash" : "0xd824ca69d07b4c971bf5d6bca42c136f683a8a3343e248862949c76770945868",
      "id" : "435000091"
    },
    {
      "hash" : "0x6744f7f92d80fc4f196252f274e997e1d56ab0aca64d91830083197244ad4d86",
      "id" : "435000020"
    },
    {
      "hash" : "0xe8a762d0bed2a364ef5d68f282d68a17d44aa36de825f06e572dbf6ba940df5c",
      "id" : "435000024"
    },
    {
      "hash" : "0xa3b747b38f4cd9d710c2961f18d4ed8cfe114ac0c8b3f567862b70503a453df0",
      "id" : "435000044"
    },
    {
      "hash" : "0xe7bc3c570e0053b12d674d9da92758e4514b54b32137b10fac2e6949d38f1487",
      "id" : "435000098"
    },
    {
      "hash" : "0x49c42e4466c0a1d9960ce56cad941b98da761974b5d4254909329244d0009e92",
      "id" : "435000099"
    },
    {
      "hash" : "0x404d56a068b6919214f6a45a4c351ee6b42ed749e0d76678db94bb01028ce554",
      "id" : "435000051"
    },
    {
      "hash" : "0x8885537ed589b79cdcf16e732e0035909e9f81a6fcdbf073772bb02cbd288f44",
      "id" : "435000032"
    }
  ]
}