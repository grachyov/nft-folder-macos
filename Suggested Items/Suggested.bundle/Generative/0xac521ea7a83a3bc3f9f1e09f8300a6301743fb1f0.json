{
  "contractAddress" : "0xac521ea7a83a3bc3f9f1e09f8300a6301743fb1f",
  "kind" : "js",
  "projectId" : "0",
  "script" : "const project = \"Time Between the Lines is Thread Through the Mind\";\r\nconsole.log(`${project} v5.0 Â© Matto 2024`);\r\nconsole.log(`TOKEN ENTROPY: ${tokenData.hash}`);\r\nlet skeuomorphic = tokenData.plot == true ? false : true;\r\nconst tokenId = tokenData.tokenId;\r\nconst attributes = {};\r\nconst urlParams = new URLSearchParams(window.location.search);\r\nconst customSig = urlParams.get(\"signature\");\r\nlet customOp = urlParams.get(\"optimization\");\r\nif (customOp) { \r\n  customOp = customOp.toUpperCase();\r\n}\r\nconst altMode = urlParams.get(\"alternate\");\r\nconst skeuMode = urlParams.get(\"skeuomorphic\");\r\nlet modeDesc = [\"SKEUOMORPHIC\", \"SIMPLE\"];\r\nlet spreadDesc = [\"MINIMUM\", \"SOME\", \"MORE\", \"MAXIMUM\"];\r\nlet penSuggestion = [];\r\nif (skeuMode == \"true\") {\r\n  skeuomorphic = true;\r\n  console.log(`CUSTOM MODE: ${modeDesc[0]}`);\r\n} else if (skeuMode == \"false\") {\r\n  skeuomorphic = false;\r\n  console.log(`CUSTOM MODE: ${modeDesc[1]}`);\r\n} else {\r\n  console.log(\"DEFAULT MODE: \" + (skeuomorphic ? modeDesc[0] : modeDesc[1]));\r\n}\r\nconsole.log(\"\");\r\nlet seed = makeSeed(tokenData.hash);\r\nlet nonce = 0;\r\nlet showSignature = customSig == \"false\" ? false : true;\r\nlet circlesCount = 0;\r\nconst numGroups = selectByProbs([5,6,4,7,3], fractionalRand());\r\nconst m = (rand(0, 200) \/ 100) - 1;\r\nlet svg, sig;\r\nlet groupedLines = \"\";\r\nlet texturedLines = \"\";\r\nlet gappedPoints = [];\r\nlet palettes = [];\r\nlet points = [];\r\nconst allOptDesc = [\"ANTI\", \"LAPS\", \"STANDARD\", \"MAXIMUM\"];\r\nconst defaultOpt = selectByProbs([3, 2, 1, 0], fractionalRand());\r\nlet optimization = allOptDesc.indexOf(customOp);\r\nif (optimization === -1) {\r\n    optimization = defaultOpt;\r\n}\r\nlet optDesc = allOptDesc[optimization];\r\nlet dark = selectByProbs([0, 1], fractionalRand());\r\nif (altMode == \"true\") {\r\n  console.log(\"Alternate Mode selected, switching paper and pens.\");\r\n  dark = dark == 1 ? 0 : 1;\r\n}\r\nlet perpGap = selectByProbs([true, false], fractionalRand());\r\nconst bkg = dark == 1 ? 22 : 250;\r\nconst penCollection = dark == 0 ? \"Stabilo\" : \"Gelly Roll\";\r\nconst paletteArray = [\r\n  [\r\n    { hex: \"#83553b\", name: \"Brown\", id: 45 },\r\n    { hex: \"#d74143\", name: \"Dark Red\", id: 50 },\r\n    { hex: \"#f75c45\", name: \"Carmine\", id: 48 },\r\n    { hex: \"#ff8b15\", name: \"Pale Vermillion\", id: 30 },\r\n    { hex: \"#ffb814\", name: \"Orange\", id: 54 },\r\n    { hex: \"#ffd913\", name: \"Yellow\", id: 44 },\r\n    { hex: \"#fff248\", name: \"Lemon Yellow\", id: 24 },\r\n    { hex: \"#b7c800\", name: \"Light Green\", id: 33 },\r\n    { hex: \"#4c8b06\", name: \"Leaf Green\", id: 43 },\r\n    { hex: \"#1c6a27\", name: \"Green\", id: 36 },\r\n    { hex: \"#3d47b3\", name: \"Ultramarine\", id: 32 },\r\n    { hex: \"#3074e5\", name: \"Dark Blue\", id: 41 },\r\n    { hex: \"#3093f8\", name: \"Light Blue\", id: 31 },\r\n    { hex: \"#58b6ff\", name: \"Azure\", id: 57 },\r\n    { hex: \"#c9c4c4\", name: \"Light Cold Gray\", id: 94 },\r\n    { hex: \"#a59da5\", name: \"Medium Cold Gray\", id: 95 },\r\n    { hex: \"#665e61\", name: \"Dark Gray\", id: 96 },\r\n    { hex: \"#2d2828\", name: \"Black\", id: 46 },\r\n  ],\r\n  [\r\n    { hex: \"#E9E9E9\", name: \"Platinum\", id: 50 },\r\n    { hex: \"#85CFF5\", name: \"Pale Azure\", id: 425 },\r\n    { hex: \"#7696DC\", name: \"Vista Blue\", id: \"437p\" },\r\n    { hex: \"#2A6CD0\", name: \"Celtic Blue\", id: 438 },\r\n    { hex: \"#109EE0\", name: \"Celestial Blue\", id: 436 },\r\n    { hex: \"#97DCD6\", name: \"Tiffany Blue\", id: \"426p\" },\r\n    { hex: \"#28DBD5\", name: \"Turquoise\", id: 429 },\r\n    { hex: \"#85D18A\", name: \"Emerald\", id: 428 },\r\n    { hex: \"#E1EC7A\", name: \"Mindaro\", id: \"403p\" },\r\n    { hex: \"#E7B968\", name: \"Earth Yellow\", id: \"405p\" },\r\n    { hex: \"#D0866D\", name: \"Burnt Sienna\", id: 412 },\r\n    { hex: \"#DB5D6E\", name: \"Indian Red\", id: 419 },\r\n    { hex: \"#CE6ABC\", name: \"Sky Magenta\", id: 421 },\r\n    { hex: \"#9774D3\", name: \"Amethyst\", id: 424 },\r\n    { hex: \"#AB98E0\", name: \"Wisteria\", id: 423 },\r\n    { hex: \"#D2AFDB\", name: \"Lilac\", id: \"420p\" },\r\n    { hex: \"#838A93\", name: \"Slate Gray\", id: 444 },\r\n    { hex: \"#513E3A\", name: \"Van Dyke\", id: 417 },\r\n  ],\r\n  [\r\n    { hex: \"#EDECE4\", name: \"Metallic Silver\", id: 553 },\r\n    { hex: \"#FFD062\", name: \"Metallic Gold\", id: 551 },\r\n    { hex: \"#F8BEB6\", name: \"Metallic Red\", id: 519 },\r\n  ]\r\n];\r\nif (dark == 1 && numGroups == 3) {\r\n  dark = 2;\r\n}\r\nconst startingColor = rand(0, paletteArray[dark].length - 1);\r\nconst paletteSpread = dark < 2 ? selectByProbs([1,2,3,4], fractionalRand()) :\r\n  1;\r\nconsole.log(\"EXTENDED ATTRIBUTES:\");\r\nfor (let i = 0; i < numGroups + 1; i++) {\r\n  palettes[i] = paletteArray[dark][(startingColor + (i * paletteSpread)) % paletteArray[dark].length];\r\n  let name = `Group ${i + 1} Color`;\r\n  if (i == numGroups) {\r\n    name = \"Signature Color\";\r\n  }\r\n  penSuggestion[i] = `Suggested Pen Color: ${penCollection} #${palettes[i].id}`;\r\n  console.log(`${name}: ${palettes[i].name} (${palettes[i].hex}) - ${penSuggestion[i]}`);\r\n}\r\naddAttribute(\"COLOR GROUPS\", `${numGroups}`);\r\naddAttribute(\"COLOR SPREAD\", spreadDesc[paletteSpread - 1]);\r\naddAttribute(\"PAPER\", dark > 0 ? \"DARK\" : \"LIGHT\");\r\naddAttribute(\"COMPOSITION\", perpGap ? \"BISECTED\" : \"WHOLE\");\r\naddAttribute(\"SLOPE\", -1 * m.toFixed(2));\r\naddAttribute(\"OPTIMIZATION\", optDesc);\r\nconst svgStart = `<?xml version=\"1.0\" encoding=\"utf-8\"?><svg viewBox=\"0 0 1000 1000\" style=\"background-color:rgb(${bkg},${bkg},${bkg})\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">`;\r\nconst suggestedThickness = \"Suggested line thickness: plot side length (mm) divided by 400.\";\r\ndraw();\r\n\r\nfunction setup() {\r\n  noCanvas();\r\n  noLoop();\r\n}\r\n\r\nfunction draw() {\r\n  const ySpacing = 2.6 - (1 - Math.abs(m)) \/ 3;\r\n  let lineNum = 0;\r\n  for (let b = -2000; b < 2000; b += ySpacing ) {\r\n    const x0 = Math.max(0, -b \/ m);\r\n    const x1 = Math.min(1000, (1000 - b) \/ m);\r\n    const y0 = b + x0 * m;\r\n    const y1 = b + x1 * m;\r\n    const clipped = getClippedLine(x0, y0, x1, y1);\r\n    if (clipped) {\r\n      lineWithGaps(clipped.x0, clipped.y0, clipped.x1, clipped.y1, lineNum);\r\n    }\r\n    lineNum++;\r\n  }\r\n\r\n  \/\/ 0: anti, 1: laps (handled elsewhere), 2: normal, 3: maximum\r\n  if (optimization == 0) {\r\n    points = sortPointPairs(points, true, false);\r\n  } else if (optimization == 2) {\r\n    points = sortPointPairs(points, false, true); \r\n  } else if (optimization == 3) {\r\n    points = sortPointPairs(points, true, true);\r\n  }\r\n  const linesPerGroup = Math.ceil(points.length \/ numGroups);\r\n  let pointIndex = 0;\r\n  for (let i = 0; i < numGroups; i++) {\r\n    groupedLines += G(i + 1, palettes[i].hex, 2.5, palettes[i].name, penSuggestion[i]);\r\n    texturedLines += G(i + 1, palettes[i].hex, 1.5, palettes[i].name, penSuggestion[i]);\r\n    for (let j = 0; j < linesPerGroup && pointIndex < points.length; j++) {\r\n      if (isNaN(points[pointIndex].y2)) {\r\n        break;\r\n      }\r\n      groupedLines += P([points[pointIndex].x1, points[pointIndex].y1, points[pointIndex].x2, points[pointIndex].y2]);\r\n      if (skeuomorphic) {\r\n        texturedLines += line2dots(points[pointIndex].x1, points[pointIndex].y1, points[pointIndex].x2, points[pointIndex].y2);\r\n      }\r\n      pointIndex++;\r\n    }\r\n    groupedLines += \"<\/g>\";\r\n    texturedLines +=\"<\/g>\";\r\n  }\r\n  console.log(`Background Line Segments: ${pointIndex}`);\r\n  if (skeuomorphic) {\r\n    console.log(`Composing Circles: ${circlesCount}`);\r\n  }\r\n  console.log(suggestedThickness);\r\n  console.log(\"License: CC BY-NC 4.0\");\r\n  sig = signature();\r\n  svg = skeuomorphic ? svgStart + texturedLines : svgStart + groupedLines;\r\n  updateSVG();\r\n}\r\n\r\nfunction signature() {\r\n  let sigLinePoints = [\r\n    [924,956,920,956], \r\n    [920,956,920,860], \r\n    [920,860,940,872], \r\n    [940,872,960,860], \r\n    [960,860,960,956], \r\n    [960,956,956,956],\r\n    [928,902,940,872],\r\n    [940,872,952,902],\r\n    [934,888,946,888],\r\n    [920,902,960,902],\r\n    [932,902,932,926],\r\n    [948,902,948,926]\r\n  ];\r\n  let str;\r\n  if (skeuomorphic) {\r\n    str = G(\"signature\", palettes[numGroups].hex, 1.5, palettes[numGroups].name, penSuggestion[numGroups]);\r\n    for (let i=0; i<sigLinePoints.length; i++) {\r\n      str += line2dots(sigLinePoints[i][0], sigLinePoints[i][1], sigLinePoints[i][2], sigLinePoints[i][3]);\r\n    }\r\n    str += circle2dots(940, 940, 15);\r\n  } else {\r\n    str = G(\"signature\", palettes[numGroups].hex, 2.5, palettes[numGroups].name, penSuggestion[numGroups]);\r\n    str += `<polyline points=\"924,956 920,956 920,860 940,872 960,860 960,956 956,956\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\/>`;\r\n    str += `<polyline points=\"928,902 940,872 952,902\" stroke-linejoin=\"bevel\" \/>`;\r\n    str = str + P(sigLinePoints[8]) + P(sigLinePoints[9]) + P(sigLinePoints[10]) + P(sigLinePoints[11]);\r\n    str += C([940, 940, 15]);\r\n  }\r\n  str += \"<\/g>\";\r\n  return str;\r\n}\r\n\r\nfunction G(groupNum, hex, strokeW, paletteName, penSuggestion) {\r\n  return `<g id=\"group-${groupNum}-${hex}-${paletteName}\" style=\"stroke:${hex}; stroke-width: ${strokeW}px; stroke-opacity:1; fill-opacity:0\"><desc>${paletteName} - ${penSuggestion}. ${suggestedThickness}<\/desc>`;\r\n}\r\n\r\nfunction P(vars) {\r\n  return `<path d=\"M ${vars[0]} ${vars[1]} L ${vars[2]} ${vars[3]}\" stroke-linecap=\"round\" \/>`\r\n}\r\n\r\nfunction C(vars) {\r\n  return `<circle cx=\"${vars[0]}\" cy=\"${vars[1]}\" r=\"${vars[2]}\" \/>`;\r\n}\r\n\r\nfunction crossesBisector(x1, y1, x2, y2) {\r\n  const xIntersection = ((500 + 500 \/ m + m * x1 - y1) \/ (m + 1 \/ m));\r\n  const yIntersection = 500 - (1 \/ m) * (xIntersection - 500);\r\n  return xIntersection >= Math.min(x1, x2) && xIntersection <= Math.max(x1, x2) &&\r\n         yIntersection >= Math.min(y1, y2) && yIntersection <= Math.max(y1, y2);\r\n}\r\n\r\nfunction addAttribute(trait_type, value) {\r\n  console.log(`${trait_type}: ${value}`);\r\n  attributes[trait_type] = value;\r\n}\r\n\r\nfunction makeSeed(input) {\r\n  let s = 1;\r\n  for (let i = 0; i < (input.length - 2) \/ 2; i++) {\r\n    let v = parseInt(input.slice(2 + i * 2, 4 + i * 2), 16);\r\n    s = ((s * v) % 999999999999) + 1\r\n  }\r\n  return s;\r\n}\r\n\r\nfunction fractionalRand() {\r\n  return rand(1,100)\/100;\r\n}\r\n\r\nfunction rand(min, max) {\r\n  const range = max - min + 1;\r\n  const v = (seed % range) + min;\r\n  newSeed();\r\n  return Math.floor(v);\r\n}\r\n\r\nfunction newSeed() {\r\n  nonce++;\r\n  let bigSeed = BigInt(seed);\r\n  const bigNonce = BigInt(nonce);\r\n  const bigMultiplier = BigInt(35932678341237);\r\n  const bigModulus = BigInt(999999999999);\r\n  bigSeed = (bigSeed * bigMultiplier + bigNonce) % bigModulus + BigInt(1);\r\n  if (bigSeed <= Number.MAX_SAFE_INTEGER) {\r\n    seed = Number(bigSeed);\r\n  } else {\r\n    console.log(\"Seed exceeded safe range, reseeding...\");\r\n    seed %= 999999999999;\r\n  }\r\n}\r\n\r\ndocument.addEventListener(\"keydown\", function (event) {\r\n  if (!tokenData.plot) {\r\n    const k = event.key.toUpperCase();\r\n    if (k === \"H\") {\r\n      console.log(`Toggling signature, please be patient. ${circlesCount} circles need to be redrawn...`);\r\n      showSignature = !showSignature;\r\n      document.body.innerHTML = '';\r\n      updateSVG();\r\n    } else if (k === \"S\") {\r\n      let mS = skeuomorphic ? modeDesc[0] : modeDesc[1];\r\n      console.log(`Saving ${mS}-mode SVG with ${optDesc} Optimization...`)\r\n      saveStrings([assembleComp() + \"<\/svg>\"], `TBTLITTTM-${tokenId}-${mS}-${optDesc}`, \"svg\");\r\n    }\r\n  }\r\n});\r\n\r\nfunction saveStrings(data, filename, extension) {\r\n  const blob = new Blob([data], {type: 'text\/plain'});\r\n  let anchor = document.createElement('a');\r\n  anchor.download = `${filename}.${extension}`;\r\n  anchor.href = window.URL.createObjectURL(blob);\r\n  anchor.style.display = 'none';\r\n  document.body.appendChild(anchor);\r\n  anchor.click();\r\n  document.body.removeChild(anchor);\r\n}\r\n\r\nfunction assembleComp() {\r\n  let comp = svg;\r\n  if (showSignature) {\r\n    comp += sig;\r\n  }\r\n  return comp;\r\n}\r\n\r\nfunction updateSVG() {\r\n  document.body.insertAdjacentHTML('beforeend', assembleComp() + \"<\/svg>\");\r\n}\r\n\r\nfunction selectByProbs(list, randomValue) {\r\n  const totalWeight = list.reduce(function(acc, item, index) {\r\n    return acc + (1 \/ (index + 2));\r\n  }, 0);\r\n  const threshold = totalWeight * randomValue;\r\n  let currentSum = 0;\r\n  for (let i = 0; i < list.length; i++) {\r\n    currentSum += 1 \/ (i + 2);\r\n    if (currentSum >= threshold) {\r\n      return list[i];\r\n    }\r\n  }\r\n  return list[list.length - 1];\r\n}\r\n\r\nfunction getY(x0, y0, x1, y1, x) {\r\n  const m = (y1 - y0) \/ (x1 - x0);\r\n  const b = y0 - m * x0;\r\n  const y = m * x + b;\r\n  return y;\r\n}\r\n\r\nfunction lineWithGaps(x0, y0, x1, y1, lineNum) {\r\n  let xT, yT, xE, yE;\r\n  let tempPoints = [];\r\n  if(x0 > x1) {\r\n    xT = x0;\r\n    yT = y0;\r\n    x0 = x1;\r\n    y0 = y1;\r\n    x1 = xT;\r\n    y1 = yT;\r\n  }\r\n  let xS = x0;\r\n  let yS = y0;\r\n  let lfg = true;\r\n  while (lfg) {\r\n    let dS;\r\n    let dnm = [[60,4,48,12],[80,12,40,8]];\r\n    dS = 0;\r\n    let lSeg = rand((1000 \/ dnm[dS][0]), (1000 \/ dnm[dS][1]));\r\n    let gSeg = rand((1000 \/ dnm[dS][2]), (1000 \/ dnm[dS][3]));\r\n    xS + lSeg > x1 ? xE = x1 : xE = xS + lSeg;\r\n    yE = getY(x0, y0, x1, y1, xE);\r\n\r\n    if (!perpGap || !crossesBisector(xS, yS, xE, yE)) {\r\n      tempPoints.push({x1: xS, y1: yS, x2: xE, y2: yE});\r\n    }\r\n    xE + gSeg > x1 ? lfg = false : xS = xE + gSeg;\r\n    xS = xE + gSeg;\r\n    yS = getY(x0, y0, x1, y1, xS);\r\n  }\r\n  for (let i = 0; i < tempPoints.length; i++) {\r\n    if (optimization == 1 && lineNum % 2 == 1) { \/\/ laps optimization\r\n      const j = tempPoints.length - i - 1;\r\n      points.push({x1: tempPoints[j].x2, y1: tempPoints[j].y2, x2: tempPoints[j].x1, y2: tempPoints[j].y1});\r\n    } else {\r\n      points.push(tempPoints[i]);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getClippedLine(x0, y0, x1, y1) {\r\n  const xmin = rand(1, 100) < 33 ? rand(4, 100) : rand(4, 20);\r\n  const ymin = rand(1, 100) < 33 ? rand(4, 100) : rand(4, 20);\r\n  const xmax = 1000 - rand(4, 20);\r\n  const ymax = rand(1,100) < 33 ? 1000 - rand(4, 60) : 1000 - rand(4, 20);\r\n\r\n  const inside = (x, y) => x >= xmin && x <= xmax && y >= ymin && y <= ymax;\r\n  if (inside(x0, y0) && inside(x1, y1)) {\r\n    return { x0, y0, x1, y1 };\r\n  }\r\n  const m = (y1 - y0) \/ (x1 - x0);\r\n  const b = y0 - m * x0;\r\n  const xLeft = xmin;\r\n  const yLeft = m * xLeft + b;\r\n  const xRight = xmax;\r\n  const yRight = m * xRight + b;\r\n  const yTop = ymin;\r\n  const xTop = (yTop - b) \/ m;\r\n  const yBottom = ymax;\r\n  const xBottom = (yBottom - b) \/ m;\r\n  const intersections = [\r\n    { x: xLeft, y: yLeft },\r\n    { x: xRight, y: yRight },\r\n    { x: xTop, y: yTop },\r\n    { x: xBottom, y: yBottom }\r\n  ];\r\n  const validIntersections = intersections.filter(p => inside(p.x, p.y));\r\n  if (validIntersections.length >= 2) {\r\n    return {\r\n      x0: validIntersections[0].x,\r\n      y0: validIntersections[0].y,\r\n      x1: validIntersections[1].x,\r\n      y1: validIntersections[1].y\r\n    };\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction distance(x1, y1, x2, y2) {\r\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\r\n}\r\n\r\nfunction sortPointPairs(pointPairs, allowReverse, optimize) {\r\n  const sortedPairs = [pointPairs.shift()]; \r\n  while (pointPairs.length > 0) {\r\n      let selectedPairIndex = 0;\r\n      let selectedDistance = optimize ? Infinity : -Infinity;\r\n      let reverse = false;\r\n      for (let i = 0; i < pointPairs.length; i++) {\r\n          const pair = pointPairs[i];\r\n          const lastPair = sortedPairs[sortedPairs.length - 1];\r\n          const distances = [\r\n              distance(lastPair.x2, lastPair.y2, pair.x1, pair.y1),\r\n              distance(lastPair.x2, lastPair.y2, pair.x2, pair.y2)\r\n          ];\r\n          if (allowReverse) {\r\n              distances.push(\r\n                  distance(lastPair.x2, lastPair.y2, pair.x2, pair.y2),\r\n                  distance(lastPair.x2, lastPair.y2, pair.x1, pair.y1)\r\n              );\r\n          }\r\n          distances.forEach((dist, index) => {\r\n              if (optimize ? dist < selectedDistance : dist > selectedDistance) {\r\n                  selectedDistance = dist;\r\n                  selectedPairIndex = i;\r\n                  reverse = index % 2 !== 0;\r\n              }\r\n          });\r\n      }\r\n      let selectedPair = pointPairs.splice(selectedPairIndex, 1)[0];\r\n      if (reverse && allowReverse) {\r\n          [selectedPair.x1, selectedPair.x2] = [selectedPair.x2, selectedPair.x1];\r\n          [selectedPair.y1, selectedPair.y2] = [selectedPair.y2, selectedPair.y1];\r\n      }\r\n      sortedPairs.push(selectedPair);\r\n  }\r\n  return sortedPairs;\r\n}\r\n\r\nfunction line2dots(x1, y1, x2, y2) {\r\n  const d = .4;\r\n  let texture = \"\";\r\n    const totalDistance = distance(x1, y1, x2, y2);\r\n    const steps = totalDistance \/ d;\r\n    const xStep = (x2 - x1) \/ steps;\r\n    const yStep = (y2 - y1) \/ steps;\r\n    for (let i = 0; i <= steps; i++) {\r\n      const r = fractionalRand() * .75;\r\n      let tempX = x1 + i * xStep;\r\n      let tempY = y1 + i * yStep;\r\n      if (i === steps) {\r\n          tempX = x2;\r\n          tempY = y2;\r\n      }\r\n      texture += C([tempX.toFixed(2), tempY.toFixed(2), r]);\r\n      circlesCount++;\r\n    }\r\n    return texture;\r\n}\r\n\r\nfunction circle2dots(cx, cy, r) {\r\n  const d = 0.4;\r\n  let texture = \"\";\r\n  const circumference = 2 * Math.PI * r;\r\n  const steps = circumference \/ d;\r\n  for (let i = 0; i < steps; i++) {\r\n      const theta = (i \/ steps) * 2 * Math.PI;\r\n      const dotX = cx + r * Math.cos(theta);\r\n      const dotY = cy + r * Math.sin(theta);\r\n      const dotR = fractionalRand() * 0.75;\r\n      texture += C([dotX.toFixed(2), dotY.toFixed(2), dotR]);\r\n      circlesCount++;\r\n  }\r\n  return texture;\r\n}",
  "tokens" : [
    {
      "hash" : "0x3061220aec244331ed957e07ac06beee800b8a2fce0c986cf7f738c740a1309a",
      "id" : "28"
    },
    {
      "hash" : "0xaea8c795edde73ed517987f97eb4ab14201fe4795c97bfcf4fd220cd0306c421",
      "id" : "20"
    },
    {
      "hash" : "0x9888c9df8ab76a7ef11e112ab55ffbbf59dc355317ed679859ab0ab6940b5fd3",
      "id" : "14"
    },
    {
      "hash" : "0xe9b3dfabd6134ec73f4f3a75975a5df0680f769dfa53e19cc05f0f79944a9b39",
      "id" : "26"
    },
    {
      "hash" : "0xe46f29eb234344af582a53daf49de9a422b451ce2c9ad1718276c4267c598770",
      "id" : "32"
    },
    {
      "hash" : "0x71e6c86f52db63db344aedbc98d9ecb1e77ac6d1c16c5f66921bef8fddc2b3ff",
      "id" : "21"
    },
    {
      "hash" : "0x72ddd613a6a4b162e5c4453a95f8fbbac2defb8d504b83069de84aeae07234b4",
      "id" : "13"
    },
    {
      "hash" : "0x7e858cb5daebb5c3687c971c1ff47c9c4b1daa68e69d436b130c5f6e7cea39ad",
      "id" : "30"
    },
    {
      "hash" : "0xaa47ac66aa4ff88e0870fd71bee17cc9225a3c8e34fa9a3f329f877153d38eff",
      "id" : "9"
    },
    {
      "hash" : "0x2c4583b65b6156dc7582745d25c60b35d5e9a4a5111c527d94cddf7b0a4b0eb5",
      "id" : "27"
    },
    {
      "hash" : "0x7cea3b762ae149c9ebc8baa076a7baf2e7b6217e2e2d9fe2c9e0e6446afa3c76",
      "id" : "16"
    },
    {
      "hash" : "0xb64f02cbcfd04e8b2a4731646ef9f293fa27a1599de639db7115797492512590",
      "id" : "18"
    },
    {
      "hash" : "0x302cf415a30cd26e580d08c158f04b6622b95f006c098e4aa05e283e95b49d3d",
      "id" : "29"
    },
    {
      "hash" : "0xa0188d4321fe9f0980cc7475bab1adb28855b89fe8a53e640ffa81d52cd2c93a",
      "id" : "6"
    },
    {
      "hash" : "0x527b8fc7269962eef764c6829e0706fb4c02a1f9645479b7e3cb4b47bf5912fb",
      "id" : "7"
    },
    {
      "hash" : "0xd6f71db0c11efb44d5d7dd865b6a06aadd105467066985ba4ff25bd2878393e3",
      "id" : "33"
    },
    {
      "hash" : "0x0785c7728872dcbb552b3fcaa8e07aa963229f58056de89c83f812d80f453f31",
      "id" : "34"
    },
    {
      "hash" : "0x1224df69d8dfc91df99cb5711d6353aa76a89af5890aad7d40d6363c4a0a0064",
      "id" : "5"
    },
    {
      "hash" : "0x03c6efd5ddbef1d81df0e6c6d69505f00f098b1a42b2a3b89b4694719a774ee3",
      "id" : "17"
    },
    {
      "hash" : "0x3064dcf6c705239b95a2aaeb904affa26ede8733507d79c2c74736a30a8053ec",
      "id" : "22"
    },
    {
      "hash" : "0xc4b2a7eb91d15d1958a456ff22453d5709a5290e4a9bd43ae613265e16744ab1",
      "id" : "0"
    },
    {
      "hash" : "0xf5a42cc792f3327ca724eb94f8629527f87cdc94d060cb96989db44ae7d94d17",
      "id" : "38"
    },
    {
      "hash" : "0xa8596e307a9e1c119b292e47a0fba5f4022e869a3ba082b2387c0f972e062d2b",
      "id" : "39"
    },
    {
      "hash" : "0x66f3847869ee5d3466e3ac529b0e4b90a84beed4b5588cc16c0b98f8ea738c62",
      "id" : "2"
    },
    {
      "hash" : "0x757b807db30936a7fe1f51aa6fc93abe96b9b0fe6c2335263ba42048cbe8cceb",
      "id" : "10"
    },
    {
      "hash" : "0xde5979ad6cce8fec8796100e3b84217614cad2d7f9d3d545f971430dff3aa2e1",
      "id" : "31"
    },
    {
      "hash" : "0xb5a2ce69a2593aad5050868786aa4c769dc10d1fddcb69088ab46a4d1dbde134",
      "id" : "11"
    },
    {
      "hash" : "0xf55241f92b497468d155c9074a2861a42fe1c68b4e3d11ea8cdfd89010d9c5b1",
      "id" : "23"
    },
    {
      "hash" : "0xff60e2d9fbeffb214deed83b7c59682adf3da135f1019f4018072d3fcc538fff",
      "id" : "37"
    },
    {
      "hash" : "0x35a8dffc3f388b045686ab1a40ac00aab8ef43661b7ed8fabb234082627789ca",
      "id" : "25"
    },
    {
      "hash" : "0x062c804f1df719c9afab54c1f49bb514f9421d385296df4215a5d63f276ed0a4",
      "id" : "1"
    },
    {
      "hash" : "0x92af8e94480a9d2851d256d7ea65af29602ecc8291c53065cdb496a7bab107f4",
      "id" : "12"
    },
    {
      "hash" : "0x7f021f56ee7a5dfffb1477b16cad229b158af018d8266806b502def8cf2c2ddb",
      "id" : "4"
    },
    {
      "hash" : "0xc8d97b57439fac730857f4d28037543ed0f72b784ecdcfab9a83fbd80be1f155",
      "id" : "19"
    },
    {
      "hash" : "0xf87ec1ae42ec6d562655cca546f54601bd73fc9497a1804f789ed24778e96c93",
      "id" : "3"
    },
    {
      "hash" : "0xf90022365c79273d6b4e3bced8c5e0f99d62544a7cb658bf72bfdc8344953973",
      "id" : "24"
    },
    {
      "hash" : "0x12e2b73ac7ff6dc62c1cf567622969821679b8365d518f840575676cfaf7efe9",
      "id" : "15"
    },
    {
      "hash" : "0x06b29df2be8826bc9d7b9e56e42b244be2a36a54717e62dba3badd81aa5e2685",
      "id" : "8"
    },
    {
      "hash" : "0x1ea56c0d92387736420b167eea50bd1f417c532c2302576ec84e2647966928b2",
      "id" : "35"
    },
    {
      "hash" : "0xb5367ae840b2c7b7331f3692951f109689ad8ecde8f3daf33b5dae9df0ba62ff",
      "id" : "36"
    }
  ]
}