{
  "contractAddress" : "0x32d4be5ee74376e08038d652d4dc26e62c67f436",
  "kind" : "p5js100",
  "projectId" : "18",
  "script" : "\/*\n * variables\n *\/\n\nlet debugMode = false;\nconst DEFAULT_HEIGHT = 1920;\nconst DEFAULT_WIDTH = 1080;\nconst MAX_HEIGHT = 3840;\nconst MAX_WIDTH = 2160;\nlet R;\nlet WIDTH, HEIGHT;\nlet hash;\nlet hashPairs = [];\nlet decPairs = [];\nlet mainCanvas;\nlet nSeed;\nlet rSeed;\nlet canvasScale;\nlet saveBoolean = false;\nlet params, features;\nlet graphics, centerPosition, centerAngle;\n\n\/*\n * setup p5.js\n *\/\nfunction setup() {\n  params = setupParams();\n\n  setupCanvas();\n  frameRate(60);\n\n  if (debugMode) {\n    let features = structuredClone(params);\n    delete features.Colors;\n    delete features.LineColors;\n    delete features.LineDiagonals;\n    delete features.LineParams;\n    print(\"================================================\");\n    print(\"features\");\n    print(features);\n    print(\"================================================\");\n    \/\/ return features;\n  }\n}\n\n\/*\n * draw p5.js\n *\/\nfunction draw() {\n  clear();\n  drawPattern();\n  if (debugMode) {\n    \/\/ imageMode(CORNER);\n    \/\/ image(graphics, 0, 0, 100, 100);\n  }\n}\n\nfunction drawPattern() {\n  graphics.clear();\n  let offset = graphics.width \/ 20;\n  let margin = offset \/ 1;\n  let cellSize = params.Cells;\n  let d = int(\n    (graphics.width - offset * 2 - margin * (cellSize - 1)) \/ cellSize\n  );\n  for (let j = 0; j < cellSize; j++) {\n    for (let i = 0; i < cellSize; i++) {\n      let index = j * cellSize + i;\n      let lineParam = params.LineParams[index];\n      let lineDiagonal = lineParam.LineDiagonal;\n      let x = int(offset + i * (d + margin));\n      let y = int(offset + j * (d + margin));\n      if (lineDiagonal) {\n        drawFreqLine(x, y, x + d, y + d, lineParam, graphics);\n      } else {\n        drawFreqLine(x + d, y, x, y + d, lineParam, graphics);\n      }\n    }\n  }\n\n  clear();\n  blendMode(BLEND);\n  switch (params.BlendMode) {\n    case \"ADD\":\n      background(0, 0, 10);\n      blendMode(ADD);\n      break;\n    case \"BLEND\":\n      background(0, 0, 0);\n      blendMode(BLEND);\n      break;\n    case \"BURN\":\n      background(0, 0, 92);\n      blendMode(BURN);\n      break;\n  }\n\n  for (let i = 0; i < params.Iteration; i++) {\n    let eachLayer = graphics.get();\n    eachLayer.resize(\n      (layerScale = int(\n        map(\n          sin(\n            ((i * 360) \/ params.Iteration) * map(params.Cells, 4, 13, 1, 3) +\n              2 * frameCount\n          ),\n          -1,\n          1,\n          WIDTH \/ 50,\n          WIDTH \/ 4\n        )\n      )),\n      layerScale\n    );\n    push();\n    translate(WIDTH \/ 2, HEIGHT \/ 2);\n    translate(centerPosition.x, centerPosition.y);\n    switch (params.Position) {\n      case \"Planet\":\n        break;\n      case \"Satellite\":\n        translate(\n          (cos(+(i \/ params.Iteration) * 360) * WIDTH) \/ 8,\n          (sin(+(i \/ params.Iteration) * 360) * HEIGHT) \/ 8\n        );\n        break;\n      case \"Comet\":\n        translate(\n          (cos(frameCount * 1 + (i \/ params.Iteration) * 360) * WIDTH) \/ 8,\n          (sin((frameCount * 2) \/ 3 + (i \/ params.Iteration) * 360) * HEIGHT) \/\n            8\n        );\n        break;\n    }\n\n    rotate(\n      ((i * 360) \/ params.Iteration) * 1.5 +\n        360 \/ params.Iteration \/ 2 +\n        (frameCount \/ 2) * (params.Rotation == \"Clockwise\" ? 1 : -1)\n    );\n    scale((m = tan(((i * 90) \/ params.Iteration + frameCount \/ 5) % 90)));\n    let nx = sin((i * 90) \/ params.Iteration + frameCount \/ 5) * 100;\n    let ny = cos((i * 90) \/ params.Iteration + frameCount \/ 6) * 100;\n    if (params.Distortion == \"On\") {\n      shearY(10 * sin((i \/ params.Iteration) * 360 + frameCount \/ 2));\n    }\n    imageMode(CENTER);\n    image(eachLayer, nx, ny, width, width);\n    if (params.BlendMode == \"BURN\") {\n      image(eachLayer, nx, ny, width, width);\n    }\n    pop();\n  }\n}\n\nfunction drawFreqLine(x1, y1, x2, y2, lineParam, target) {\n  let d = dist(x1, y1, x2, y2);\n  let a = atan2(y2 - y1, x2 - x1);\n  let h1 = lineParam.FreqA;\n  let h2 = lineParam.FreqB;\n  let f1 = map(sin(x1 + y1 * width + frameCount * h1), -1, 1, 0, 1);\n  let f2 = map(cos(x2 + y2 * width + frameCount * h2), -1, 1, 0, 1);\n\n  target.drawingContext.setLineDash[d];\n  target.drawingContext.lineDashOffset =\n    ((max(f1, f2) * d + frameCount) \/ 10) % (d * 2);\n\n  f1 = easeInOutCirc(f1);\n  f2 = easeInOutCirc(f2);\n  let s1 = d * f1;\n  let s2 = d * f2;\n  let strokeColor = lineParam.Color.lineColor;\n  let pointColor = lineParam.Color.pointColor;\n  target.strokeCap(SQUARE);\n\n  if (lineParam.Type == \"Line\") {\n    let t = dist(s1, 0, s2, 0) \/ d;\n    target.push();\n    target.translate(x1, y1);\n    target.rotate(a);\n\n    target.strokeCap(PROJECT);\n    target.noFill();\n    target.stroke(strokeColor);\n\n    target.strokeWeight((d \/ 50) * max(1 - f2, 1 - f1) * sqrt(2));\n    target.line(s1, 0, s2, 0);\n    \/\/ line(0, 0, d*t, 0);\n\n    if (lineParam.Point == \"Circle\") {\n      target.stroke(pointColor);\n      target.strokeWeight((d \/ 10) * (1 - f1) * sqrt(2));\n      target.point(s1, 0);\n      target.strokeWeight((d \/ 10) * (1 - f2) * sqrt(2));\n      target.point(s2, 0);\n    } else if (lineParam.Point == \"Square\") {\n      target.push();\n      target.translate(s1, 0);\n      target.rotate(45 + f1 * 360);\n      target.rectMode(CENTER);\n      target.fill(strokeColor);\n      target.noStroke();\n      target.rect(0, 0, ((d \/ 5) * (1 - f1)) \/ sqrt(2));\n      target.pop();\n\n      target.push();\n      target.translate(s2, 0);\n      target.rotate(45 + f2 * 360);\n      target.rectMode(CENTER);\n      target.fill(strokeColor);\n      target.noStroke();\n      target.rect(0, 0, ((d \/ 5) * (1 - f1)) \/ sqrt(2));\n      target.pop();\n    }\n    target.pop();\n  } else if (lineParam.Type == \"Arc\") {\n    let a1 = 90 * f1;\n    let a2 = 90 - 90 * f2;\n    let d2 = d \/ sqrt(2);\n    target.push();\n    target.translate(min(x1, x2) + d2 \/ 2, min(y1, y2) + d2 \/ 2);\n    target.rotate(lineParam.Angle);\n    target.translate(-d2 \/ 2, -d2 \/ 2);\n    target.noFill();\n    target.stroke(strokeColor);\n    target.strokeWeight((d \/ 50) * max(1 - f2, 1 - f1) * sqrt(2));\n    if (abs(a1 - a2) > 0.1) {\n      target.arc(0, 0, d2 * 2, d2 * 2, min(a1, a2), max(a1, a2));\n    }\n    if (lineParam.Point == \"Circle\") {\n      target.stroke(pointColor);\n      target.strokeWeight((d \/ 10) * (1 - f1) * sqrt(2));\n      target.point(cos(a1) * d2, sin(a1) * d2);\n      target.strokeWeight((d \/ 10) * (1 - f2) * sqrt(2));\n      target.point(cos(a2) * d2, sin(a2) * d2);\n    } else if (lineParam.Point == \"Square\") {\n      target.push();\n      target.translate(cos(a1) * d2, sin(a1) * d2);\n      target.rotate(45 + f1 * 360);\n      target.rectMode(CENTER);\n      target.fill(strokeColor);\n      target.noStroke();\n      target.rect(0, 0, ((d \/ 5) * (1 - f1)) \/ sqrt(2));\n      target.pop();\n\n      target.push();\n      target.translate(cos(a2) * d2, sin(a2) * d2);\n      target.rotate(45 + f2 * 360);\n      target.rectMode(CENTER);\n      target.fill(strokeColor);\n      target.noStroke();\n      target.rect(0, 0, ((d \/ 5) * (1 - f1)) \/ sqrt(2));\n      target.pop();\n    }\n    target.pop();\n  }\n}\n\nfunction setupParams() {\n  hash = tokenData.hash;\n  if (debugMode) {\n    \/\/ hash = \"0x622fb6114b74ada47abf7a4721f697623f8c33c89adbe098367416c808cd8447\";\n  }\n  R = new Random();\n  if (debugMode) {\n    print(\"================================================\");\n    print(\"debugMode\", debugMode);\n    print(\"hash\", hash);\n    print(\"================================================\");\n  }\n  for (let j = 0; j < 32; j++) {\n    hashPairs.push(hash.slice(2 + j * 2, 4 + j * 2));\n  }\n  decPairs = hashPairs.map((x) => {\n    return parseInt(x, 16);\n  });\n\n  let params = getParams(decPairs);\n  if (debugMode) {\n    print(params);\n    print(\"================================================\");\n    print(\"Palette : \", params.Palette);\n    print(\"Colors : \", params.Colors);\n    print(\"Cells : \", params.Cells);\n    print(\"Iteration : \", params.Iteration);\n    print(\"Position : \", params.Position);\n    print(\"LineType : \", params.LineType);\n    print(\"PointType : \", params.PointType);\n    print(\"Distortion : \", params.Distortion);\n    print(\"Rotation : \", params.Rotation);\n    print(\"BlendMode : \", params.BlendMode);\n    print(\"================================================\");\n  }\n  return params;\n}\n\nfunction getParams(decPairs) {\n  const colorOjbect = colorScheme[decPairs[1] % colorScheme.length];\n  let blendModeChoices = [\"ADD\", \"BLEND\", \"BURN\"];\n  let cellSize = (decPairs[2] % 10) + 4;\n  let iteration = constrain(decPairs[3] % 20, 6, 20);\n  let lineColors = [];\n  for (let i = 0; i < cellSize * cellSize; i++) {\n    lineColors.push(R.random_choice(colorOjbect.colors));\n  }\n  let lineDiagonals = [];\n  for (let i = 0; i < cellSize * cellSize; i++) {\n    lineDiagonals.push(R.random_bool(0.5));\n  }\n  let distortion = decPairs[4] % 4 == 0 ? \"On\" : \"Off\";\n  let position = decPairs[5] % 11 > 5 ? \"Planet\" : \"Satellite\";\n  position = decPairs[5] % 11 == 0 ? \"Comet\" : position;\n\n  let rotation = decPairs[6] % 2 == 0 ? \"Clockwise\" : \"Counterclockwise\";\n\n  let blendModeChoice = R.random_choice(blendModeChoices);\n  let lineParams = [];\n  const lineType = R.random_choice([\"Line\", \"Arc\", \"Mix\"]);\n  const pointType = R.random_choice([\"Square\", \"Circle\", \"Mix\"]);\n  for (let i = 0; i < cellSize * cellSize; i++) {\n    let freqA = (R.random_num(1, 5) \/ 2) * (R.random_bool(0.5) ? -1 : 1);\n    let freqB = (R.random_num(1, 5) \/ 2) * (R.random_bool(0.5) ? -1 : 1);\n    let lineDiagonal = R.random_bool(0.5);\n    let strokeColor = R.random_choice(colorOjbect.colors);\n    let c1 = R.random_choice(colorOjbect.colors);\n    let c2 = R.random_choice(colorOjbect.colors);\n    while (c1 == c2) {\n      c2 = R.random_choice(colorOjbect.colors);\n    }\n    strokeColor = {\n      lineColor: c1,\n      pointColor: c2,\n    };\n\n    let type;\n    if (lineType == \"Arc\") {\n      type = \"Arc\";\n    } else if (lineType == \"Line\") {\n      type = \"Line\";\n    } else {\n      type = R.random_choice([\"Line\", \"Arc\"]);\n    }\n    let pType;\n    if (pointType == \"Square\") {\n      pType = \"Square\";\n    } else if (pointType == \"Circle\") {\n      pType = \"Circle\";\n    } else {\n      pType = R.random_choice([\"Square\", \"Circle\"]);\n    }\n    lineParams.push({\n      Color: strokeColor,\n      LineDiagonal: lineDiagonal,\n      FreqA: freqA,\n      FreqB: freqB,\n      Type: type,\n      Point: pType,\n      Angle: R.random_choice([0, 90, 180, 270]),\n    });\n  }\n  centerAngle = R.random_num(0, 360);\n  return {\n    Palette: colorOjbect.name,\n    Colors: colorOjbect.colors,\n    Cells: cellSize,\n    Iteration: iteration,\n    Position: position,\n    LineType: lineType,\n    PointType: pointType,\n    Distortion: distortion,\n    Rotation: rotation,\n    LineColors: lineColors,\n    LineDiagonals: lineDiagonals,\n    LineParams: lineParams,\n    BlendMode: blendModeChoice,\n  };\n}\n\nfunction setupCanvas() {\n  pixelDensity(1);\n  WIDTH = windowWidth;\n  HEIGHT = windowHeight;\n  canvasScale = HEIGHT \/ DEFAULT_HEIGHT;\n  mainCanvas = createCanvas(WIDTH, HEIGHT);\n  let w = constrain(\n    max(WIDTH, HEIGHT) \/ 4,\n    max(WIDTH, HEIGHT) \/ 2,\n    MAX_HEIGHT \/ 2\n  );\n\n  graphics = createGraphics(w, w);\n  colorMode(HSB, 360, 100, 100, 100);\n  angleMode(DEGREES);\n  graphics.colorMode(HSB, 360, 100, 100, 100);\n  graphics.angleMode(DEGREES);\n  noSmooth();\n  centerPosition = createVector(0, 0);\n  if (decPairs[6] % 10 < 3) {\n    centerPosition.add(\n      p5.Vector.fromAngle(centerAngle).mult(min(WIDTH, HEIGHT) \/ 10)\n    );\n  }\n}\n\nfunction calculateCanvasSize() {\n  const aspectRatioWidth = 9;\n  const aspectRatioHeight = 16;\n  let canvasWidth, canvasHeight;\n  if (windowWidth * (aspectRatioHeight \/ aspectRatioWidth) <= windowHeight) {\n    canvasWidth = windowWidth;\n    canvasHeight = windowWidth * (aspectRatioHeight \/ aspectRatioWidth);\n  } else {\n    canvasHeight = windowHeight;\n    canvasWidth = windowHeight * (aspectRatioWidth \/ aspectRatioHeight);\n  }\n  if (canvasHeight > MAX_HEIGHT) {\n    canvasHeight = MAX_HEIGHT;\n    canvasWidth = canvasHeight * (aspectRatioWidth \/ aspectRatioHeight);\n  }\n  if (saveBoolean) {\n    canvasWidth = MAX_WIDTH;\n    canvasHeight = MAX_HEIGHT;\n  }\n  return {\n    width: canvasWidth,\n    height: canvasHeight,\n  };\n}\n\n\/**\n * color palette for drawing\n *\/\nconst colorScheme = [\n  {\n    name: \"Benedictus\",\n    colors: [\"#F27EA9\", \"#366CD9\", \"#5EADF2\", \"#636E73\", \"#F2E6D8\"],\n  },\n  {\n    name: \"Cross\",\n    colors: [\"#D962AF\", \"#58A6A6\", \"#8AA66F\", \"#F29F05\", \"#F26D6D\"],\n  },\n  {\n    name: \"Demuth\",\n    colors: [\"#222940\", \"#D98E04\", \"#F2A950\", \"#BF3E21\", \"#F2F2F2\"],\n  },\n  {\n    name: \"Hiroshige\",\n    colors: [\"#1B618C\", \"#55CCD9\", \"#F2BC57\", \"#F2DAAC\", \"#F24949\"],\n  },\n  {\n    name: \"Hokusai\",\n    colors: [\"#074A59\", \"#F2C166\", \"#F28241\", \"#F26B5E\", \"#F2F2F2\"],\n  },\n  {\n    name: \"Indigo\",\n    colors: [\"#023059\", \"#459DBF\", \"#87BF60\", \"#D9D16A\", \"#F2F2F2\"],\n  },\n  {\n    name: \"Java\",\n    colors: [\"#632973\", \"#02734A\", \"#F25C05\", \"#F29188\", \"#F2E0DF\"],\n  },\n  {\n    name: \"Kandinsky\",\n    colors: [\"#8D95A6\", \"#0A7360\", \"#F28705\", \"#D98825\", \"#F2F2F2\"],\n  },\n  {\n    name: \"Monet\",\n    colors: [\"#4146A6\", \"#063573\", \"#5EC8F2\", \"#8C4E03\", \"#D98A29\"],\n  },\n  {\n    name: \"Nizami\",\n    colors: [\"#034AA6\", \"#72B6F2\", \"#73BFB1\", \"#F2A30F\", \"#F26F63\"],\n  },\n  {\n    name: \"Renoir\",\n    colors: [\"#303E8C\", \"#F2AE2E\", \"#F28705\", \"#D91414\", \"#F2F2F2\"],\n  },\n  {\n    name: \"VanGogh\",\n    colors: [\"#424D8C\", \"#84A9BF\", \"#C1D9CE\", \"#F2B705\", \"#F25C05\"],\n  },\n  {\n    name: \"RiverSide\",\n    colors: [\"#906FA6\", \"#025951\", \"#252625\", \"#D99191\", \"#F2F2F2\"],\n  },\n];\n\n\/**\n * Random Generator Class\n *\/\nclass Random {\n  constructor() {\n    this.useA = false;\n    let sfc32 = function (uint128Hex) {\n      let a = parseInt(uint128Hex.substr(0, 8), 16);\n      let b = parseInt(uint128Hex.substr(8, 8), 16);\n      let c = parseInt(uint128Hex.substr(16, 8), 16);\n      let d = parseInt(uint128Hex.substr(24, 8), 16);\n      return function () {\n        a |= 0;\n        b |= 0;\n        c |= 0;\n        d |= 0;\n        let t = (((a + b) | 0) + d) | 0;\n        d = (d + 1) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        c = (c + t) | 0;\n        return (t >>> 0) \/ 4294967296;\n      };\n    };\n    \/\/ seed prngA with first half of tokenData.hash\n    this.prngA = new sfc32(hash.substr(2, 32));\n    \/\/ seed prngB with second half of tokenData.hash\n    this.prngB = new sfc32(hash.substr(34, 32));\n    for (let i = 0; i < 1e6; i += 2) {\n      this.prngA();\n      this.prngB();\n    }\n  }\n  \/\/ random number between 0 (inclusive) and 1 (exclusive)\n  random_dec() {\n    this.useA = !this.useA;\n    return this.useA ? this.prngA() : this.prngB();\n  }\n  \/\/ random number between a (inclusive) and b (exclusive)\n  random_num(a, b) {\n    return a + (b - a) * this.random_dec();\n  }\n  \/\/ random integer between a (inclusive) and b (inclusive)\n  \/\/ requires a < b for proper probability distribution\n  random_int(a, b) {\n    return Math.floor(this.random_num(a, b + 1));\n  }\n  \/\/ random boolean with p as percent liklihood of true\n  random_bool(p) {\n    return this.random_dec() < p;\n  }\n  \/\/ random value in an array of items\n  random_choice(list) {\n    return list[this.random_int(0, list.length - 1)];\n  }\n}\n\nfunction windowResized() {\n  resizeCanvas(windowWidth, windowHeight);\n  WIDTH = windowWidth;\n  HEIGHT = windowHeight;\n  let w = constrain(\n    max(WIDTH, HEIGHT) \/ 4,\n    max(WIDTH, HEIGHT) \/ 2,\n    MAX_HEIGHT \/ 2\n  );\n  centerPosition = createVector(0, 0);\n  if (decPairs[6] % 10 < 3) {\n    centerPosition.add(\n      p5.Vector.fromAngle(centerAngle).mult(min(WIDTH, HEIGHT) \/ 10)\n    );\n  }\n  graphics.width = w;\n  graphics.height = w;\n}\n\nfunction easeInOutCirc(x) {\n  return x < 0.5\n    ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) \/ 2\n    : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) \/ 2;\n}\n\nfunction easeInOutElastic(x) {\n  const c5 = (2 * Math.PI) \/ 4.5;\n  return x === 0\n    ? 0\n    : x === 1\n    ? 1\n    : x < 0.5\n    ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) \/ 2\n    : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) \/ 2 + 1;\n}\n",
  "tokens" : [
    {
      "hash" : "0xee4105160935f6aa2d47c1b5e0873dfc5a2a02dd0958e516c00c0c4e075c1094",
      "id" : "18000030"
    },
    {
      "hash" : "0x849569235307b6e6ab96c532bd101d81ea99755c3dee6c2371d40cd983a76785",
      "id" : "18000041"
    },
    {
      "hash" : "0xea94daee8ed687453a64ff00af8a47cb8f5ca5797588b792ce337b7cd8b2a8e0",
      "id" : "18000000"
    },
    {
      "hash" : "0xae1dd23df4f24f6e008a27dbdb6f38aede37dd48f460e41164ee8b11007b447e",
      "id" : "18000015"
    },
    {
      "hash" : "0x6e861cad78b40e78cd0f9f22f97812820b8fd7c0eeac0f735f71eeac3c8f7ef0",
      "id" : "18000047"
    },
    {
      "hash" : "0x6571bac6bbe5f4e79f0490e8a8d53201f94dcc6c73da4ac931d6da86a1f70eac",
      "id" : "18000044"
    },
    {
      "hash" : "0xfd283ea4001d490ce55e578bf7158c563ddd7447ceba3826979e91ed0035af16",
      "id" : "18000005"
    },
    {
      "hash" : "0x75faf276fdc08ef589f53f243f0254423b70acd110c361697248cf6f586c592a",
      "id" : "18000046"
    },
    {
      "hash" : "0x9bc99f63392845e3c952dd5bd5be4118a4f63cb96cb18996b72775c878a969f5",
      "id" : "18000012"
    },
    {
      "hash" : "0xccf75a69396cf9da4e64a860184e6058de7b3d0e2a702d089864ec9db55607cc",
      "id" : "18000027"
    },
    {
      "hash" : "0xc37522949235a413482f39ffefbcc884491a2d53bc67042e6c4bd96ed8d39839",
      "id" : "18000033"
    },
    {
      "hash" : "0x67c140f7c33f05e1bee21b31c67c077e8ce961e437215e63e98b3f6c86114476",
      "id" : "18000013"
    },
    {
      "hash" : "0x8611ce8eeca95e879f6b51d37be43885427b05d8e2c44de0860c551f77ed7e3d",
      "id" : "18000022"
    },
    {
      "hash" : "0xf1a6e1fb385501d26b3313b82ca6f006d8f22616306e45d71d33e1efd351bd47",
      "id" : "18000023"
    },
    {
      "hash" : "0xe9c4c82a76c531fc417095fdc4e82dbaf37e568a4d1e12fe456250ac1c0eb347",
      "id" : "18000032"
    },
    {
      "hash" : "0x9323a82d6025d7c68ecde0e969d5a503ea2085164e340c9b2b681d640f468859",
      "id" : "18000040"
    },
    {
      "hash" : "0xef8157b9e91b7058dd13056e5b99f86c951b823f66b33197f3bd3e0a74290af8",
      "id" : "18000003"
    },
    {
      "hash" : "0x1748e2678b9547fb945315fd3db62e0824588c58e34c385c4f70ffa11efbb382",
      "id" : "18000039"
    },
    {
      "hash" : "0x1efa20e95bff06d83f2edb7e4c6420173de1ad3b83b41f9491366e3a3ac017ef",
      "id" : "18000011"
    },
    {
      "hash" : "0xa363bf180aade203833cd8f8fa7a9d4fa66bab96e6195ddea4a5adb01d0f6d46",
      "id" : "18000042"
    },
    {
      "hash" : "0xd006bb0d90671d8aa6e0b587fc82167e30db28f8a3cf10594548e6de52c15794",
      "id" : "18000020"
    },
    {
      "hash" : "0x1936b14527a4b83b59354bce97189c56a5c36ca5fe2292dc16082e90537f03d6",
      "id" : "18000035"
    },
    {
      "hash" : "0x995d65b9f3f56857267e395e7bf8e17f74bc279c3cdfa8cabaa3873b51089dda",
      "id" : "18000038"
    },
    {
      "hash" : "0xc94be3b9bbf8788c36e2ba0784c86b7e0ca1328d80bd9a2909b9e1614fbbde44",
      "id" : "18000016"
    },
    {
      "hash" : "0x3223b8034bc06adb8098c9810f15f173cf0e5d1de95c8aa2da6f38f8779d8d4f",
      "id" : "18000029"
    },
    {
      "hash" : "0x78bd49f9c17c8a7cfcb8b50c811b6e78673ca877cdb231618b25db02b10dc281",
      "id" : "18000017"
    },
    {
      "hash" : "0xa5f8322a1eb75954e1fce4b3ef534b1e91254f7266d6ed927ed22e7f7c2266eb",
      "id" : "18000006"
    },
    {
      "hash" : "0x17e9fe43fdd1c7bdd4daa898aa684f8983d0164a3c611cfe5d7b8f314633c43d",
      "id" : "18000024"
    },
    {
      "hash" : "0x2fbdd530faa14285178053aa9b7bb2dfd84a92b48bfd225f66833698e74f770c",
      "id" : "18000025"
    },
    {
      "hash" : "0x5eb88c55f3c9a169360c9f5462e0b4238dbba2d0c7d835b3dcae5bfb3bda29c9",
      "id" : "18000049"
    },
    {
      "hash" : "0x120b31836ebda911a8cee97d64401f35a13bf484b07edd1886ebb45c3057c709",
      "id" : "18000001"
    },
    {
      "hash" : "0x33a8cf90e6b86224fc3aecb3bb6f144a0d0b88736dd3dfc20e14e52dcf9a4765",
      "id" : "18000007"
    },
    {
      "hash" : "0x1e1c1d5ae64c4d67ad0b54e4b2ae9af10e6d4db4ac086197a50c8c52683fe438",
      "id" : "18000010"
    },
    {
      "hash" : "0xb78549f28ee8068378d6c7435a718c2817889cb5b0876cb30fbdd609f16ef5fa",
      "id" : "18000014"
    },
    {
      "hash" : "0x25d906db7c6328cdda217b19c003cbbefe9ca8f8cd416cb0a94044acfc4f7535",
      "id" : "18000021"
    },
    {
      "hash" : "0x695832eb2c69325cc5e5cff97dc914f5246c07904e8a61b07f565ca97e1d8583",
      "id" : "18000031"
    },
    {
      "hash" : "0x3ce8bebea56c840e79ed2165f4afaee578e56ea11a6e478a7ec90d12fcdce4b0",
      "id" : "18000028"
    },
    {
      "hash" : "0xaa35cc49007ad177fe53b3eb5f024edb0961a6e644a44489ceecbe74f3672007",
      "id" : "18000034"
    },
    {
      "hash" : "0xd98b5b255e155519d4919dea0d450f866a8addd6ca0bbbe711da7a47f0ac0f35",
      "id" : "18000045"
    },
    {
      "hash" : "0xead7458390ab15dcc38e56ddf5e60fbb74982dd0510085e806a75c576f71492b",
      "id" : "18000026"
    },
    {
      "hash" : "0x72c4a995d707b3ad1cf0e7b818dd7a6ec7acbdf5d284deaa43db857542fcb621",
      "id" : "18000002"
    },
    {
      "hash" : "0x0da1fbc22fb2d4af217e79e70700437abf6209cffff1a94ee026e24e6973f6b9",
      "id" : "18000004"
    },
    {
      "hash" : "0xc0ddb4ed8fdbea37ae64a1fd91445c4719498c5a03176fa85e94f91181a86ee6",
      "id" : "18000043"
    },
    {
      "hash" : "0x1a5e738efb1c2faab28ad1874804ed5e01c35329c8f651e724cbfacb1726246a",
      "id" : "18000048"
    },
    {
      "hash" : "0xe2bb721a7b1b0c4977c1522727acebc4bce0249434b4dd1b9137d924f3f510a1",
      "id" : "18000008"
    },
    {
      "hash" : "0x41a54a4b332d85be35729f19e19a1534e87aadf8d5152eeb156db596abee9649",
      "id" : "18000019"
    },
    {
      "hash" : "0xa2a613dffad4bbdc1edd1d65be2d51ae981d15abb6f6d9d00fb4888d8f779ec8",
      "id" : "18000009"
    },
    {
      "hash" : "0xaa13a05fb5a8d42a101df4069f8cee79934797d893e5fd36ebe30b5f7f3ea841",
      "id" : "18000018"
    },
    {
      "hash" : "0x6b46b3c5744fd14e968128f034a7439bda8e66785a0fc8ae4be494ba7e93f8e8",
      "id" : "18000036"
    },
    {
      "hash" : "0xffb9d147cef4f890febe934d83eef474e22a736c5df5864d96f2887f7d11ae66",
      "id" : "18000037"
    }
  ]
}