{
  "abId" : "18",
  "address" : "0x32d4be5ee74376e08038d652d4dc26e62c67f436",
  "kind" : "p5js100",
  "name" : "JaggedMemories",
  "screensaverFileName" : "JaggedMemories",
  "value" : "\/*\n * variables\n *\/\n\nlet debugMode = false;\nconst DEFAULT_HEIGHT = 1920;\nconst DEFAULT_WIDTH = 1080;\nconst MAX_HEIGHT = 3840;\nconst MAX_WIDTH = 2160;\nlet R;\nlet WIDTH, HEIGHT;\nlet hash;\nlet hashPairs = [];\nlet decPairs = [];\nlet mainCanvas;\nlet nSeed;\nlet rSeed;\nlet canvasScale;\nlet saveBoolean = false;\nlet params, features;\nlet graphics, centerPosition, centerAngle;\n\n\/*\n * setup p5.js\n *\/\nfunction setup() {\n  params = setupParams();\n\n  setupCanvas();\n  frameRate(60);\n\n  if (debugMode) {\n    let features = structuredClone(params);\n    delete features.Colors;\n    delete features.LineColors;\n    delete features.LineDiagonals;\n    delete features.LineParams;\n    print(\"================================================\");\n    print(\"features\");\n    print(features);\n    print(\"================================================\");\n    \/\/ return features;\n  }\n}\n\n\/*\n * draw p5.js\n *\/\nfunction draw() {\n  clear();\n  drawPattern();\n  if (debugMode) {\n    \/\/ imageMode(CORNER);\n    \/\/ image(graphics, 0, 0, 100, 100);\n  }\n}\n\nfunction drawPattern() {\n  graphics.clear();\n  let offset = graphics.width \/ 20;\n  let margin = offset \/ 1;\n  let cellSize = params.Cells;\n  let d = int(\n    (graphics.width - offset * 2 - margin * (cellSize - 1)) \/ cellSize\n  );\n  for (let j = 0; j < cellSize; j++) {\n    for (let i = 0; i < cellSize; i++) {\n      let index = j * cellSize + i;\n      let lineParam = params.LineParams[index];\n      let lineDiagonal = lineParam.LineDiagonal;\n      let x = int(offset + i * (d + margin));\n      let y = int(offset + j * (d + margin));\n      if (lineDiagonal) {\n        drawFreqLine(x, y, x + d, y + d, lineParam, graphics);\n      } else {\n        drawFreqLine(x + d, y, x, y + d, lineParam, graphics);\n      }\n    }\n  }\n\n  clear();\n  blendMode(BLEND);\n  switch (params.BlendMode) {\n    case \"ADD\":\n      background(0, 0, 10);\n      blendMode(ADD);\n      break;\n    case \"BLEND\":\n      background(0, 0, 0);\n      blendMode(BLEND);\n      break;\n    case \"BURN\":\n      background(0, 0, 92);\n      blendMode(BURN);\n      break;\n  }\n\n  for (let i = 0; i < params.Iteration; i++) {\n    let eachLayer = graphics.get();\n    eachLayer.resize(\n      (layerScale = int(\n        map(\n          sin(\n            ((i * 360) \/ params.Iteration) * map(params.Cells, 4, 13, 1, 3) +\n              2 * frameCount\n          ),\n          -1,\n          1,\n          WIDTH \/ 50,\n          WIDTH \/ 4\n        )\n      )),\n      layerScale\n    );\n    push();\n    translate(WIDTH \/ 2, HEIGHT \/ 2);\n    translate(centerPosition.x, centerPosition.y);\n    switch (params.Position) {\n      case \"Planet\":\n        break;\n      case \"Satellite\":\n        translate(\n          (cos(+(i \/ params.Iteration) * 360) * WIDTH) \/ 8,\n          (sin(+(i \/ params.Iteration) * 360) * HEIGHT) \/ 8\n        );\n        break;\n      case \"Comet\":\n        translate(\n          (cos(frameCount * 1 + (i \/ params.Iteration) * 360) * WIDTH) \/ 8,\n          (sin((frameCount * 2) \/ 3 + (i \/ params.Iteration) * 360) * HEIGHT) \/\n            8\n        );\n        break;\n    }\n\n    rotate(\n      ((i * 360) \/ params.Iteration) * 1.5 +\n        360 \/ params.Iteration \/ 2 +\n        (frameCount \/ 2) * (params.Rotation == \"Clockwise\" ? 1 : -1)\n    );\n    scale((m = tan(((i * 90) \/ params.Iteration + frameCount \/ 5) % 90)));\n    let nx = sin((i * 90) \/ params.Iteration + frameCount \/ 5) * 100;\n    let ny = cos((i * 90) \/ params.Iteration + frameCount \/ 6) * 100;\n    if (params.Distortion == \"On\") {\n      shearY(10 * sin((i \/ params.Iteration) * 360 + frameCount \/ 2));\n    }\n    imageMode(CENTER);\n    image(eachLayer, nx, ny, width, width);\n    if (params.BlendMode == \"BURN\") {\n      image(eachLayer, nx, ny, width, width);\n    }\n    pop();\n  }\n}\n\nfunction drawFreqLine(x1, y1, x2, y2, lineParam, target) {\n  let d = dist(x1, y1, x2, y2);\n  let a = atan2(y2 - y1, x2 - x1);\n  let h1 = lineParam.FreqA;\n  let h2 = lineParam.FreqB;\n  let f1 = map(sin(x1 + y1 * width + frameCount * h1), -1, 1, 0, 1);\n  let f2 = map(cos(x2 + y2 * width + frameCount * h2), -1, 1, 0, 1);\n\n  target.drawingContext.setLineDash[d];\n  target.drawingContext.lineDashOffset =\n    ((max(f1, f2) * d + frameCount) \/ 10) % (d * 2);\n\n  f1 = easeInOutCirc(f1);\n  f2 = easeInOutCirc(f2);\n  let s1 = d * f1;\n  let s2 = d * f2;\n  let strokeColor = lineParam.Color.lineColor;\n  let pointColor = lineParam.Color.pointColor;\n  target.strokeCap(SQUARE);\n\n  if (lineParam.Type == \"Line\") {\n    let t = dist(s1, 0, s2, 0) \/ d;\n    target.push();\n    target.translate(x1, y1);\n    target.rotate(a);\n\n    target.strokeCap(PROJECT);\n    target.noFill();\n    target.stroke(strokeColor);\n\n    target.strokeWeight((d \/ 50) * max(1 - f2, 1 - f1) * sqrt(2));\n    target.line(s1, 0, s2, 0);\n    \/\/ line(0, 0, d*t, 0);\n\n    if (lineParam.Point == \"Circle\") {\n      target.stroke(pointColor);\n      target.strokeWeight((d \/ 10) * (1 - f1) * sqrt(2));\n      target.point(s1, 0);\n      target.strokeWeight((d \/ 10) * (1 - f2) * sqrt(2));\n      target.point(s2, 0);\n    } else if (lineParam.Point == \"Square\") {\n      target.push();\n      target.translate(s1, 0);\n      target.rotate(45 + f1 * 360);\n      target.rectMode(CENTER);\n      target.fill(strokeColor);\n      target.noStroke();\n      target.rect(0, 0, ((d \/ 5) * (1 - f1)) \/ sqrt(2));\n      target.pop();\n\n      target.push();\n      target.translate(s2, 0);\n      target.rotate(45 + f2 * 360);\n      target.rectMode(CENTER);\n      target.fill(strokeColor);\n      target.noStroke();\n      target.rect(0, 0, ((d \/ 5) * (1 - f1)) \/ sqrt(2));\n      target.pop();\n    }\n    target.pop();\n  } else if (lineParam.Type == \"Arc\") {\n    let a1 = 90 * f1;\n    let a2 = 90 - 90 * f2;\n    let d2 = d \/ sqrt(2);\n    target.push();\n    target.translate(min(x1, x2) + d2 \/ 2, min(y1, y2) + d2 \/ 2);\n    target.rotate(lineParam.Angle);\n    target.translate(-d2 \/ 2, -d2 \/ 2);\n    target.noFill();\n    target.stroke(strokeColor);\n    target.strokeWeight((d \/ 50) * max(1 - f2, 1 - f1) * sqrt(2));\n    if (abs(a1 - a2) > 0.1) {\n      target.arc(0, 0, d2 * 2, d2 * 2, min(a1, a2), max(a1, a2));\n    }\n    if (lineParam.Point == \"Circle\") {\n      target.stroke(pointColor);\n      target.strokeWeight((d \/ 10) * (1 - f1) * sqrt(2));\n      target.point(cos(a1) * d2, sin(a1) * d2);\n      target.strokeWeight((d \/ 10) * (1 - f2) * sqrt(2));\n      target.point(cos(a2) * d2, sin(a2) * d2);\n    } else if (lineParam.Point == \"Square\") {\n      target.push();\n      target.translate(cos(a1) * d2, sin(a1) * d2);\n      target.rotate(45 + f1 * 360);\n      target.rectMode(CENTER);\n      target.fill(strokeColor);\n      target.noStroke();\n      target.rect(0, 0, ((d \/ 5) * (1 - f1)) \/ sqrt(2));\n      target.pop();\n\n      target.push();\n      target.translate(cos(a2) * d2, sin(a2) * d2);\n      target.rotate(45 + f2 * 360);\n      target.rectMode(CENTER);\n      target.fill(strokeColor);\n      target.noStroke();\n      target.rect(0, 0, ((d \/ 5) * (1 - f1)) \/ sqrt(2));\n      target.pop();\n    }\n    target.pop();\n  }\n}\n\nfunction setupParams() {\n  hash = tokenData.hash;\n  if (debugMode) {\n    \/\/ hash = \"0x622fb6114b74ada47abf7a4721f697623f8c33c89adbe098367416c808cd8447\";\n  }\n  R = new Random();\n  if (debugMode) {\n    print(\"================================================\");\n    print(\"debugMode\", debugMode);\n    print(\"hash\", hash);\n    print(\"================================================\");\n  }\n  for (let j = 0; j < 32; j++) {\n    hashPairs.push(hash.slice(2 + j * 2, 4 + j * 2));\n  }\n  decPairs = hashPairs.map((x) => {\n    return parseInt(x, 16);\n  });\n\n  let params = getParams(decPairs);\n  if (debugMode) {\n    print(params);\n    print(\"================================================\");\n    print(\"Palette : \", params.Palette);\n    print(\"Colors : \", params.Colors);\n    print(\"Cells : \", params.Cells);\n    print(\"Iteration : \", params.Iteration);\n    print(\"Position : \", params.Position);\n    print(\"LineType : \", params.LineType);\n    print(\"PointType : \", params.PointType);\n    print(\"Distortion : \", params.Distortion);\n    print(\"Rotation : \", params.Rotation);\n    print(\"BlendMode : \", params.BlendMode);\n    print(\"================================================\");\n  }\n  return params;\n}\n\nfunction getParams(decPairs) {\n  const colorOjbect = colorScheme[decPairs[1] % colorScheme.length];\n  let blendModeChoices = [\"ADD\", \"BLEND\", \"BURN\"];\n  let cellSize = (decPairs[2] % 10) + 4;\n  let iteration = constrain(decPairs[3] % 20, 6, 20);\n  let lineColors = [];\n  for (let i = 0; i < cellSize * cellSize; i++) {\n    lineColors.push(R.random_choice(colorOjbect.colors));\n  }\n  let lineDiagonals = [];\n  for (let i = 0; i < cellSize * cellSize; i++) {\n    lineDiagonals.push(R.random_bool(0.5));\n  }\n  let distortion = decPairs[4] % 4 == 0 ? \"On\" : \"Off\";\n  let position = decPairs[5] % 11 > 5 ? \"Planet\" : \"Satellite\";\n  position = decPairs[5] % 11 == 0 ? \"Comet\" : position;\n\n  let rotation = decPairs[6] % 2 == 0 ? \"Clockwise\" : \"Counterclockwise\";\n\n  let blendModeChoice = R.random_choice(blendModeChoices);\n  let lineParams = [];\n  const lineType = R.random_choice([\"Line\", \"Arc\", \"Mix\"]);\n  const pointType = R.random_choice([\"Square\", \"Circle\", \"Mix\"]);\n  for (let i = 0; i < cellSize * cellSize; i++) {\n    let freqA = (R.random_num(1, 5) \/ 2) * (R.random_bool(0.5) ? -1 : 1);\n    let freqB = (R.random_num(1, 5) \/ 2) * (R.random_bool(0.5) ? -1 : 1);\n    let lineDiagonal = R.random_bool(0.5);\n    let strokeColor = R.random_choice(colorOjbect.colors);\n    let c1 = R.random_choice(colorOjbect.colors);\n    let c2 = R.random_choice(colorOjbect.colors);\n    while (c1 == c2) {\n      c2 = R.random_choice(colorOjbect.colors);\n    }\n    strokeColor = {\n      lineColor: c1,\n      pointColor: c2,\n    };\n\n    let type;\n    if (lineType == \"Arc\") {\n      type = \"Arc\";\n    } else if (lineType == \"Line\") {\n      type = \"Line\";\n    } else {\n      type = R.random_choice([\"Line\", \"Arc\"]);\n    }\n    let pType;\n    if (pointType == \"Square\") {\n      pType = \"Square\";\n    } else if (pointType == \"Circle\") {\n      pType = \"Circle\";\n    } else {\n      pType = R.random_choice([\"Square\", \"Circle\"]);\n    }\n    lineParams.push({\n      Color: strokeColor,\n      LineDiagonal: lineDiagonal,\n      FreqA: freqA,\n      FreqB: freqB,\n      Type: type,\n      Point: pType,\n      Angle: R.random_choice([0, 90, 180, 270]),\n    });\n  }\n  centerAngle = R.random_num(0, 360);\n  return {\n    Palette: colorOjbect.name,\n    Colors: colorOjbect.colors,\n    Cells: cellSize,\n    Iteration: iteration,\n    Position: position,\n    LineType: lineType,\n    PointType: pointType,\n    Distortion: distortion,\n    Rotation: rotation,\n    LineColors: lineColors,\n    LineDiagonals: lineDiagonals,\n    LineParams: lineParams,\n    BlendMode: blendModeChoice,\n  };\n}\n\nfunction setupCanvas() {\n  pixelDensity(1);\n  WIDTH = windowWidth;\n  HEIGHT = windowHeight;\n  canvasScale = HEIGHT \/ DEFAULT_HEIGHT;\n  mainCanvas = createCanvas(WIDTH, HEIGHT);\n  let w = constrain(\n    max(WIDTH, HEIGHT) \/ 4,\n    max(WIDTH, HEIGHT) \/ 2,\n    MAX_HEIGHT \/ 2\n  );\n\n  graphics = createGraphics(w, w);\n  colorMode(HSB, 360, 100, 100, 100);\n  angleMode(DEGREES);\n  graphics.colorMode(HSB, 360, 100, 100, 100);\n  graphics.angleMode(DEGREES);\n  noSmooth();\n  centerPosition = createVector(0, 0);\n  if (decPairs[6] % 10 < 3) {\n    centerPosition.add(\n      p5.Vector.fromAngle(centerAngle).mult(min(WIDTH, HEIGHT) \/ 10)\n    );\n  }\n}\n\nfunction calculateCanvasSize() {\n  const aspectRatioWidth = 9;\n  const aspectRatioHeight = 16;\n  let canvasWidth, canvasHeight;\n  if (windowWidth * (aspectRatioHeight \/ aspectRatioWidth) <= windowHeight) {\n    canvasWidth = windowWidth;\n    canvasHeight = windowWidth * (aspectRatioHeight \/ aspectRatioWidth);\n  } else {\n    canvasHeight = windowHeight;\n    canvasWidth = windowHeight * (aspectRatioWidth \/ aspectRatioHeight);\n  }\n  if (canvasHeight > MAX_HEIGHT) {\n    canvasHeight = MAX_HEIGHT;\n    canvasWidth = canvasHeight * (aspectRatioWidth \/ aspectRatioHeight);\n  }\n  if (saveBoolean) {\n    canvasWidth = MAX_WIDTH;\n    canvasHeight = MAX_HEIGHT;\n  }\n  return {\n    width: canvasWidth,\n    height: canvasHeight,\n  };\n}\n\n\/**\n * color palette for drawing\n *\/\nconst colorScheme = [\n  {\n    name: \"Benedictus\",\n    colors: [\"#F27EA9\", \"#366CD9\", \"#5EADF2\", \"#636E73\", \"#F2E6D8\"],\n  },\n  {\n    name: \"Cross\",\n    colors: [\"#D962AF\", \"#58A6A6\", \"#8AA66F\", \"#F29F05\", \"#F26D6D\"],\n  },\n  {\n    name: \"Demuth\",\n    colors: [\"#222940\", \"#D98E04\", \"#F2A950\", \"#BF3E21\", \"#F2F2F2\"],\n  },\n  {\n    name: \"Hiroshige\",\n    colors: [\"#1B618C\", \"#55CCD9\", \"#F2BC57\", \"#F2DAAC\", \"#F24949\"],\n  },\n  {\n    name: \"Hokusai\",\n    colors: [\"#074A59\", \"#F2C166\", \"#F28241\", \"#F26B5E\", \"#F2F2F2\"],\n  },\n  {\n    name: \"Indigo\",\n    colors: [\"#023059\", \"#459DBF\", \"#87BF60\", \"#D9D16A\", \"#F2F2F2\"],\n  },\n  {\n    name: \"Java\",\n    colors: [\"#632973\", \"#02734A\", \"#F25C05\", \"#F29188\", \"#F2E0DF\"],\n  },\n  {\n    name: \"Kandinsky\",\n    colors: [\"#8D95A6\", \"#0A7360\", \"#F28705\", \"#D98825\", \"#F2F2F2\"],\n  },\n  {\n    name: \"Monet\",\n    colors: [\"#4146A6\", \"#063573\", \"#5EC8F2\", \"#8C4E03\", \"#D98A29\"],\n  },\n  {\n    name: \"Nizami\",\n    colors: [\"#034AA6\", \"#72B6F2\", \"#73BFB1\", \"#F2A30F\", \"#F26F63\"],\n  },\n  {\n    name: \"Renoir\",\n    colors: [\"#303E8C\", \"#F2AE2E\", \"#F28705\", \"#D91414\", \"#F2F2F2\"],\n  },\n  {\n    name: \"VanGogh\",\n    colors: [\"#424D8C\", \"#84A9BF\", \"#C1D9CE\", \"#F2B705\", \"#F25C05\"],\n  },\n  {\n    name: \"RiverSide\",\n    colors: [\"#906FA6\", \"#025951\", \"#252625\", \"#D99191\", \"#F2F2F2\"],\n  },\n];\n\n\/**\n * Random Generator Class\n *\/\nclass Random {\n  constructor() {\n    this.useA = false;\n    let sfc32 = function (uint128Hex) {\n      let a = parseInt(uint128Hex.substr(0, 8), 16);\n      let b = parseInt(uint128Hex.substr(8, 8), 16);\n      let c = parseInt(uint128Hex.substr(16, 8), 16);\n      let d = parseInt(uint128Hex.substr(24, 8), 16);\n      return function () {\n        a |= 0;\n        b |= 0;\n        c |= 0;\n        d |= 0;\n        let t = (((a + b) | 0) + d) | 0;\n        d = (d + 1) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        c = (c + t) | 0;\n        return (t >>> 0) \/ 4294967296;\n      };\n    };\n    \/\/ seed prngA with first half of tokenData.hash\n    this.prngA = new sfc32(hash.substr(2, 32));\n    \/\/ seed prngB with second half of tokenData.hash\n    this.prngB = new sfc32(hash.substr(34, 32));\n    for (let i = 0; i < 1e6; i += 2) {\n      this.prngA();\n      this.prngB();\n    }\n  }\n  \/\/ random number between 0 (inclusive) and 1 (exclusive)\n  random_dec() {\n    this.useA = !this.useA;\n    return this.useA ? this.prngA() : this.prngB();\n  }\n  \/\/ random number between a (inclusive) and b (exclusive)\n  random_num(a, b) {\n    return a + (b - a) * this.random_dec();\n  }\n  \/\/ random integer between a (inclusive) and b (inclusive)\n  \/\/ requires a < b for proper probability distribution\n  random_int(a, b) {\n    return Math.floor(this.random_num(a, b + 1));\n  }\n  \/\/ random boolean with p as percent liklihood of true\n  random_bool(p) {\n    return this.random_dec() < p;\n  }\n  \/\/ random value in an array of items\n  random_choice(list) {\n    return list[this.random_int(0, list.length - 1)];\n  }\n}\n\nfunction windowResized() {\n  resizeCanvas(windowWidth, windowHeight);\n  WIDTH = windowWidth;\n  HEIGHT = windowHeight;\n  let w = constrain(\n    max(WIDTH, HEIGHT) \/ 4,\n    max(WIDTH, HEIGHT) \/ 2,\n    MAX_HEIGHT \/ 2\n  );\n  centerPosition = createVector(0, 0);\n  if (decPairs[6] % 10 < 3) {\n    centerPosition.add(\n      p5.Vector.fromAngle(centerAngle).mult(min(WIDTH, HEIGHT) \/ 10)\n    );\n  }\n  graphics.width = w;\n  graphics.height = w;\n}\n\nfunction easeInOutCirc(x) {\n  return x < 0.5\n    ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) \/ 2\n    : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) \/ 2;\n}\n\nfunction easeInOutElastic(x) {\n  const c5 = (2 * Math.PI) \/ 4.5;\n  return x === 0\n    ? 0\n    : x === 1\n    ? 1\n    : x < 0.5\n    ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) \/ 2\n    : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) \/ 2 + 1;\n}\n"
}